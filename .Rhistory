library(devtools)
use_gpl3_license()
use_gpl3_license()
use_tidy_description()
use_tidy_dependencies()
use_cpp11()
?UseMethod
new_unit_cube <- function(num_dim) {
obj <- new_sampler(num_dim = num_dim, subclass = "unit_cube")
obj$num_dim <- num_dim
obj
}
any(TRUE, FALSE)
?any
?inherits_all
?do.call
library(devtools)
use_testthat()
use_test()
use_test()
matrix(nrow = 10, ncol = 3)
?rlang::abort
use_test()
log_add_exp <- function(log_a, log_b) {
max(log_a, log_b) + log1p(exp(-abs(log_a - log_b)))
}
library(testthat)
?expect
dim(matrix(nrow = 50, ncol = 3))
expect_vector(result$num_call, "double")
expect_vector(result$num_iter, "double")
install.packages("distributional")
library(distributional)
my_dist <- c(dist_normal(mu = 0, sigma = 1), dist_student_t(df = 10))
my_dist
quantile(c(0.5, 0.75), my_dist)
quantile(my_dist, 0.1)
quantile(my_dist, c(0.1, 0.5))
quantile(my_dist, c(0.1, 0.75))
library(distributions3)
?quantile.Bernoulli
vapply(quantile, my_dist, probs = 0.1)
vapply(my_dist, quantile, probs = 0.1)
vapply(my_dist, quantile, double(), probs = 0.1)
vapply(my_dist, quantile, double(), p = 0.1)
?quantile
apply(c(Normal(), Normal()), quantile, probs = 0.5)
apply(c(Normal(), Normal()), FUN = quantile, probs = 0.5)
lapply(c(Normal(), Normal()), FUN = quantile, probs = 0.5)
lapply(list(Normal(), Normal()), FUN = quantile, probs = 0.5)
lapply(list(Normal(), Normal()), FUN = quantile, probs = 0.75)
my_dist <- c(Normal(), Bernoulli())
my_dist <- c(Normal(), Bernoulli())
Normal()
distributions3::distribution
?distributions3::is_distribution
use_package("distribution3")
use_package("distributions3")
support(Normal())
support(Normal()) |> class()
quantile(Normal(), probs = 0.5)
\(x) quantile(Normal(), probs = 0.5) |> class()
\(x) { quantile(Normal(), probs = 0.5) } |> class()
\(x) { quantile(Normal(), probs = 0.5) } |> is_function()
is_function(\(x) { quantile(Normal(), probs = 0.5) })
rlang::is_function(\(x) { quantile(Normal(), probs = 0.5) })
unname(support(Normal()))
summary(Normal())
print(Normal())
paste(Normal())
str(Normal())
as.character(Normal())
qnorm(0)
qnorm(1)
use_test()
map(list(list(name = "X", value = 0), list(name = NULL, value = 1)), \(x) x$name)
purrr::map(list(list(name = "X", value = 0), list(name = NULL, value = 1)), \(x) x$name)
purrr::map_chr(list(list(name = "X", value = 0), list(name = NULL, value = 1)), \(x) x$name)
purrr::map_chr(list(list(name = "X", value = 0), list(name = NULL, value = 1)), \(x) ifelse(is.null(x$name), "V", x$name))
purrr::map_chr(list(list(name = "X", value = 0), list(name = NULL, value = 1), list(name = NULL, value = 1)), \(x) ifelse(is.null(x$name), "V", x$name)) |> make.unique()
?make.unique
purrr::map_chr(list(list(name = "X", value = 0), list(name = NULL, value = 1), list(name = NULL, value = 1)), \(x) ifelse(is.null(x$name), "V", x$name)) |> make.names()
purrr::map_chr(list(list(name = "X", value = 0), list(name = NULL, value = 1), list(name = NULL, value = 1)), \(x) ifelse(is.null(x$name), "V", x$name)) |> make.names(logical = TRUE)
purrr::map_chr(list(list(name = "X", value = 0), list(name = NULL, value = 1), list(name = NULL, value = 1)), \(x) ifelse(is.null(x$name), "V", x$name)) |> make.names(unique = TRUE)
use_test()
?enframe
?tibble::enframe
library(devtools)
?use_tibble()
use_tibble()
use_test()
use_test()
use_package("tidyr")
library(tibble)
use_package("purrr")
#' Construct a ernest run object
#'
#' @inheritParams nested_sampling_impl
#' @param dead,live_u,live_point,live_lik,num_call,num_iter see nested sampler impl
#'
#' @return A validated ernest_run object
new_ernest_run <- function(...) {
out <- rlang::list2(...)
dead <- tibble::enframe(out$dead)
unit_points <- map(dead$value, "unit_point")
}
#' Construct a ernest run object
#'
#' @inheritParams nested_sampling_impl
#' @param dead,live_u,live_point,live_lik,num_call,num_iter see nested sampler impl
#'
#' @return A validated ernest_run object
new_ernest_run <- function(...) {
out <- rlang::list2(...)
dead <- tibble::enframe(out$dead)
unit_point <- map(dead$value, \(x) x[["unit_point"]])
point <- map(dead$value, \(x) x[["point"]])
}
process_dead <- function(names, out) {
unit_points <- map(out, \(x) {
r <- tibble::tibble_row(x$unit_point)
names(r) <- names
})
print(unit_points)
}
#' Construct a ernest run object
#'
#' @inheritParams nested_sampling_impl
#' @param dead,live_u,live_point,live_lik,num_call,num_iter see nested sampler impl
#'
#' @return A validated ernest_run object
new_ernest_run <- function(names, dead, ...) {
process_dead(names, dead)
# "log_lik" = log_lik_star,
# "log_vol" = log_vol,
# "log_wt" = log_wt,
# "log_z" = log_z,
# "log_z_var" = log_z_var,
# "h" = h,
# "id" = worst,
# "parent_iter" = live_birth[worst],
# "parent_id" = live_parent[worst],
# "num_call" = num_call,
# "sampler_updates" = num_update
# tibble::tibble(
#   log_lik = map_dbl(out$dead, \(x) x$log_lik),
#   proposed_iter = map_int(out$dead, \(x) x$parent_iter),
#   id = map_int(out$dead, \(x) x$id),
#   # # Points Here
#   log_z = map_dbl(out$dead, \(x) x$log_z),
#   log_z_var = map_dbl(out$dead, \(x) x$log_z_var),
#   log_wt = map_dbl(out$dead, \(x) x$log_wt),
#   num_call = map_int(out$dead, \(x) x$num_call),
#   log_vol = map_dbl(out$dead, \(x) x$log_vol),
#   information = map_dbl(out$dead, \(x) x$h),
#   bound_iter = map_int(out$dead, \(x) x$sampler_updates),
#   samples_bound = map_int(out$dead, \(x) x$sampler_updates)
# ) |> print()
}
process_dead <- function(names, out) {
unit_points <- map(out, \(x) {
r <- tibble::tibble_row(x$unit_point)
names(r) <- names
})
print(unit_points)
}
process_dead <- function(names, out) {
unit_points <- map(out, \(x) {
r <- list_c(x$unit_point)
names(r) <- names
r
})
unit_points <- tibble::tibble(flatten_dbl(unit_points))
print(unit_points)
}
process_dead <- function(names, out) {
unit_points <- map(out, \(x) {
list_c(x$unit_point)
})
unit_points <- tibble::tibble(unlist(unit_points))
print(unit_points)
}
process_dead <- function(names, out) {
unit_points <- map(out, \(x) {
list_c(x$unit_point)
})
unit_points <- do.call(rbind, unit_points)
print(unit_points)
}
?tibble::tibble
c(1,2,3)[-1]
tail(c())
tail(c(1))
tail(c(1,2,3))
tail(c(1,2,3),1)
sort("a", "b", "c")
sort(c("a", "b", "c"))
order(c("a", "b", "c"))
order(c("a", "e", "c"))
3 %% 3
3 %% 2
?update
0 %% 25
25 %% 25
sample(0L:5L, 1)
sample(1L:5L, 1)
?sample.int()
?sample.int(0)
sample.int(0)
sample.int(500)
# Choose an integer between 1 and live_size, but not equal to worst
copy <- sample.int(live_size, size = 1)
# Choose an integer between 1 and live_size, but not equal to worst
copy <- sample.int(500, size = 1)
sample.int(500, size = 1)
sample.int(500, size = 1)
sample.int(500, size = 1)
i <- 0L
for (i in 0L:20L) {
cat(i, " ", i^2, "\n")
}
print(i)
use_test()
use_test()
log(1. - 1:20 / (20 + 1.))
diff(log(1. - 1:20 / (20 + 1.)))
diff(c(0, log(1. - 1:20 / (20 + 1.))))
order(c(5, 4, 8))
log(1. - 1:20 / (20 + 1.)) + 0.5
sort(log(1. - 1:20 / (20 + 1.)))
order(log(1. - 1:20 / (20 + 1.)))
?order
order(c(5,4,9,8), decreasing = TRUE)
order(c(5,4,9,8), decreasing = FALSE)
sort(log_lik)[1]
order(c(5,4,9,8))[1]
sort(c(5,4,9,8))[1]
use_test()
?tibble::tibble
c(1,2,3)[1:]
head(c(1,2,3), -1)
exp(-8.46)
exp(-1.46)
?diff
?tibble
document()
pkgload::dev_help('compute_integral')
document()
document()
is.numeric(c(0, NULL))
is.null(c(0, NULL))
is.null(c(NULL, NULL))
is.numeric(Inf)
as.character(distributions3::Normal())
all(rlang::inherits_only(list(1,2,"c"), "double"))
all(rlang::inherits_only(list("a","b","c"), "character"))
all(rlang::inherits_only(list("a","b","c"), character))
all(rlang::inherits_only(list("a","b","c"), "character"))
?rlang::inherits_only
?do.call
?vapply
?split
rep(seq_along(c(1,2,3)), c(1,2,3))
use_test()
document()
document()
print(priors)
?inherits_only
qnorm(0.25)
0.75^2
qnorm(0.75)
0.25^2
?expect_equal
?abort
use_test()
library(devtools)
use_test()
document()
document()
use_standalone("r-lib/rlang", "types-check")
check_
is.null(character())
use_test()
document()
document()
document()
check_number_whole(9)
check_number_whole(-1, lower = 0)
document()
document()
use_test()
library(testthat)
?expect_s3_class
document()
document()
?expect_warning
?expect_named
pairlist2()
\(x) qnorm(x, ...)
tst <- \(x) qnorm(x, ...)
tst(0.1)
tst <- \(x) qnorm(x, pairlist2(...))
tst(0.1)
use_test()
test_that("Log Likelihood Binding Works", {
nested_sampling(function(x) x)
nested_sampling(function(x, y) x + y, y = 10)
})
NA
is_na(NULL)
is_na(NA)
is.na(NULL)
exp(-908.7314)
exp(-300)
exp(-151)
exp(-8)
?which.min
.Machine$integer.max
document()
document()
use_test()
document()
library(devtools)
document()
use_package("pretty_units")
use_package("prettyunits
")
use_package("prettyunits")
document()
document()
document()
document()
document()
document()
document()
use_test()
use_test()
1:500[4]
c(1:500)[4]
log(1 - 1:100 / 100 + 1)
log(0)
log(-5.6)
exp(-5.6)
exp(-4.9)
exp(-Inf)
seq_len(6)
exp(-1.004983)
exp(-1.015034)
