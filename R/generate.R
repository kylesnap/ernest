#' Run nested sampling to estimate Bayesian evidence
#'
#' Executes the nested sampling algorithm, iteratively replacing the worst live
#' point with a new sample from a likelihood-restricted prior until a stopping
#' criterion is met.
#'
#' @param x [[ernest_sampler]] or [[ernest_run]]\cr A nested sampling
#' specification.
#' @inheritDotParams compile.ernest_run -object
#' @param max_iterations `[integer(1)]`\cr The maximum number of iterations to
#' perform. Optional; if `NULL` this criterion is ignored.
#' @param max_evaluations `[integer(1)]`\cr The maximum number of
#' likelihood function evaluations to perform. Optional; if `NULL` this
#' criterion is ignored.
#' @param min_logz `[double(1)]`\cr The minimum log-ratio between the
#' current estimated evidence and the remaining evidence. Must be non-negative;
#' if set to zero, this criterion is ignored.
#' @param show_progress `[logical(1)]`\cr If `TRUE`, displays a progress spinner
#' and iteration counter during sampling. Optional; if `NULL` the global option
#' `rlib_message_verbosity` is used to determine whether to show progress.
#'
#' @returns `[ernest_run]`
#'
#' A named list containing the results of the nested sampling run, which
#' contains `nsample = nlive + niter` samples from the prior distribution.
#' This list inherits from [ernest_sampler], and additionally contains:
#' * `niter`: `[integer(1)]` Number of iterations performed.
#' * `neval`: `[integer(1)]` Total number of likelihood function evaluations.
#' Note that it is possible for a single call to a likelihood function to
#' evaluate the likelihoods of multiple parameter samples.
#' * `log_evidence`: `[double(1)]` The log-evidence estimate.
#' * `log_evidence_err`: `[double(1)]` The standard error of the log-evidence
#' estimate, estimated from `information`.
#' * `information`: `[double(1)]` The estimated Kullback-Leibler divergence.
#' * `samples`: `[list]` The posterior samples ordered by their log-likelihood
#' values:
#'   * `original`: `[matrix(double(), nsample, ndim)]` The samples
#'   transformed to the parameter space.
#'   * `unit_cube`: `[matrix(double(), nsample, ndim)]` The samples in
#'   the unit hypercube.
#' * `weights`: `[list]` Additional information on the points generated by the
#'   run:
#'   * `id`: `[integer(nsample)]` The index of each point in the live set
#'   for each sample.
#'   * `evaluations`: `[integer(nsample)]` The number of likelihood
#'   evaluations needed to replace each point.
#'   * `log_weight`: `[double(nsample)]` The log-weight of each sample.
#'   * `imp_weight`: `[double(nsample)]` The normalized importance weight
#'   for each sample. This is given by normalizing `log_weight` with
#'   `log_evidence`, then applying `exp` to the result so the weights sum to
#'   one.
#'   * `log_lik`: `[double(nsample)]` The log-likelihood for each sample.
#'   * `birth_lik`: `[double(nsample)]` The log-likelihood of the point used
#'   to create each sample.
#'
#' @details
#' At least one of `max_iterations`, `max_evaluations`, or `min_logz`
#' must specify a valid stopping criterion. Setting `min_logz` to zero while
#' leaving `max_iterations` and `max_evaluations` at their defaults will
#' result in an error.
#'
#' If `x` is an `ernest_run` object, the stopping criteria are checked against
#' the current state of the run. An error is thrown if the stopping criteria
#' have already been satisfied by `x`.
#'
#' The `min_logz` parameter controls the relative tolerance for the remaining
#' evidence in the unexplored parameter space. Sampling stops when the estimated
#' remaining evidence is sufficiently small compared to the accumulated
#' evidence.
#'
#' @references Skilling, J. (2006). Nested Sampling for General Bayesian
#' Computation. Bayesian Analysis, 1(4), 833â€“859. \doi{10.1214/06-BA127}
#'
#' @srrstats {BS2.12} The `show_progress` indicator controls whether a simple
#' spinner bar is shown during sampling.
#' @srrstats {BS4.0} References the paper containing the sampling algorithm.
#'
#' @examples
#' prior <- create_uniform_prior(lower = c(-1, -1), upper = 1)
#' ll_fn <- function(x) -sum(x^2)
#' sampler <- ernest_sampler(ll_fn, prior, nlive = 100)
#' sampler
#'
#' # Stop sampling after a set number of iterations or likelihood calls.
#' generate(sampler, max_iterations = 100)
#'
#' # The final number of calls may exceed `max_evaluations`, as `generate`
#' # only checks the number of calls when removing a live point.
#' generate(sampler, max_evaluations = 2600)
#'
#' # Use the default stopping criteria
#' \dontrun{ generate(sampler) }
#' @aliases ernest_run
#' @export
generate.ernest_sampler <- function(
  x,
  max_iterations = NULL,
  max_evaluations = NULL,
  min_logz = 0.05,
  show_progress = NULL,
  ...
) {
  preserve_seed(x)
  if (is.null(show_progress)) {
    show_progress <- getOption("rlib_message_verbosity", "default") != "quiet"
  }
  check_bool(show_progress)
  c(max_iterations, max_evaluations, min_logz) %<-%
    check_stopping_criteria(
      max_iterations,
      max_evaluations,
      min_logz
    )
  x <- compile(x, ...)

  results <- nested_sampling_impl(
    x = x,
    max_iterations = max_iterations,
    max_evaluations = max_evaluations,
    min_logz = min_logz,
    show_progress = show_progress
  )
  new_ernest_run(x, results)
}

#' @srrstats {BS2.8} Calling generate on an ernest_run will continue the run
#' from the last known live set.
#'
#' @rdname generate.ernest_sampler
#' @export
generate.ernest_run <- function(
  x,
  max_iterations = NULL,
  max_evaluations = NULL,
  min_logz = 0.05,
  show_progress = NULL,
  ...
) {
  preserve_seed(x)
  if (is.null(show_progress)) {
    show_progress <- getOption("rlib_message_verbosity", "default") != "quiet"
  }
  check_bool(show_progress)
  x <- compile(x, ...)
  if (inherits_only(x, "ernest_sampler")) {
    args <- list2(...)
    return(generate(
      x,
      max_iterations = max_iterations,
      max_evaluations = max_evaluations,
      min_logz = min_logz,
      show_progress = show_progress
    ))
  }

  cur_iter <- x$niter
  cureval <- x$neval
  prev_integration <- compute_integral(x$weights$log_lik, x$niter, x$nlive)
  last_criterion <- prev_integration$log_lik[cur_iter]
  log_z <- prev_integration$log_evidence[cur_iter]
  log_vol <- prev_integration$log_volume[cur_iter]
  d_logz <- logaddexp(
    0,
    max(prev_integration$log_lik[1:cur_iter]) + log_vol - log_z
  )

  c(max_iterations, max_evaluations, min_logz) %<-%
    check_stopping_criteria(
      max_iterations,
      max_evaluations,
      min_logz,
      cur_iter,
      cureval,
      d_logz
    )

  results <- nested_sampling_impl(
    x = x,
    max_iterations = max_iterations,
    max_evaluations = max_evaluations,
    min_logz = min_logz,
    last_criterion = last_criterion,
    log_vol = log_vol,
    log_z = log_z,
    curiter = cur_iter,
    cureval = cureval,
    show_progress = show_progress
  )
  new_ernest_run(x, results)
}

#' Check and validate stopping criteria for nested sampling
#'
#' @param max_iterations Maximum number of iterations to perform.
#' @param max_evaluations Maximum number of likelihood function evals.
#' @param min_logz Minimum log-ratio between current estimated evidence and
#' remaining evidence.
#' @param cur_it Current iteration.
#' @param cureval Current number of likelihood calls.
#' @param d_logz Current log-ratio for evidence.
#' @param call Environment for error reporting.
#'
#' @return A named vector of stopping criteria: `max_iterations`,
#' `max_evaluations`, and `min_logz`.
#' @noRd
check_stopping_criteria <- function(
  max_iterations,
  max_evaluations,
  min_logz,
  cur_it = NULL,
  cureval = NULL,
  d_logz = NULL,
  call = caller_env()
) {
  check_number_whole(max_iterations, min = 1, allow_null = TRUE, call = call)
  check_number_whole(max_evaluations, min = 1, allow_null = TRUE, call = call)
  check_number_decimal(min_logz, min = 0, call = call)
  no_stopping <- identical(min_logz, 0) &&
    is.null(max_iterations) &&
    is.null(max_evaluations)
  if (no_stopping) {
    cli::cli_abort(
      c(
        "Can't perform nested sampling without any stopping criteria.",
        "i" = "Have you set either `max_iterations` or `max_evaluations`?"
      ),
      call = call
    )
  }

  max_iterations <- max_iterations %||% .Machine$integer.max
  max_evaluations <- max_evaluations %||% .Machine$integer.max

  if (!is.null(cur_it) && cur_it >= max_iterations) {
    cli::cli_abort(
      c(
        "`max_iterations` must be strictly larger than {cur_it}.",
        "x" = "`x` already contains previously-generated samples.",
        "i" = "Should you use `clear` to erase previous samples from `x`?"
      ),
      call = call
    )
  }
  if (!is.null(cureval) && cureval >= max_evaluations) {
    cli::cli_abort(
      c(
        "`max_evaluations` must be strictly larger than {cureval}.",
        "x" = "`x` already contains previously-generated samples.",
        "i" = "Should you use `clear` to erase previous samples from `x`?"
      ),
      call = call
    )
  }
  if (!is.null(d_logz) && min_logz >= d_logz) {
    d_logz_format <- pretty_round(d_logz, digits = 4)
    cli::cli_abort(
      c(
        "`min_logz` must be strictly smaller than {d_logz_format}.",
        "x" = "`x` already contains previously-generated samples.",
        "i" = "Should you use `clear` to erase previous samples from `x`?"
      ),
      call = call
    )
  }

  c(
    "max_iterations" = as.integer(max_iterations),
    "max_evaluations" = as.integer(max_evaluations),
    "min_logz" = as.double(min_logz)
  )
}
