#' Create a new likelihood-restricted prior sampler (LRPS)
#'
#' @description
#' Nested sampling relies on generating a series of points in the prior space
#' with increasing log-likelihood values. This is accomplished through using an
#' likelihood-restricted prior sampler (LRPS), which provides a technique to
#' generate identically and independently distributed points from the prior
#' space, subject to a hard likelihood constraint.
#'
#' If you want to create your own LRPS, you may do so by subclassing
#' `new_ernest_lrps`. You will also need to provide S3 methods for [propose()]
#' and [update_lrps()] for your subclass.
#'
#' @param unit_log_fn,ndim These values are provided when [nested_sampling] is
#' called with a given `ernest_lrps`:
#' * `unit_log_fn` (function, optional) A function that takes a matrix of
#' points in the unit cube and returns a numeric vector of log-likelihood
#' values.
#' * `n_dim` (integer, optional) The number of dimensions of the prior space.
#' @param max_loop (strictly positive integer) The maximum number of attempts
#' to generate points through region-based sampling methods. Normally hidden
#' from users, but can be set through the option `ernest.max_loop`.
#' @param cache (environment, optional) An environment to use for caching
#' values. If `NULL`, a new environment is created.
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Name-value pairs for
#' additional elements of samplers that subclass this LRPS.
#' @param .class (character vector, optional) The subclasses of this LRPS.
#' @inheritParams rlang::check_exclusive
#'
#' @returns An LRPS specification, which is a list containing the inputs used
#' as arguments to the function, along with a class specific to the type
#' of LRPS being created.
#' @aliases ernest_lrps
#' @keywords internal
#' @export
new_ernest_lrps <- function(
  unit_log_fn = NULL,
  n_dim = NULL,
  max_loop = getOption("ernest.max_loop", 1e6L),
  cache = NULL,
  ...,
  .class = NULL,
  .call = caller_env()
) {
  check_function(unit_log_fn, allow_null = TRUE, call = .call)
  check_number_whole(n_dim, min = 1, allow_null = TRUE, call = .call)
  check_number_whole(
    max_loop,
    min = 1,
    allow_infinite = FALSE,
    arg = "getOption('ernest.max_loop')",
    call = .call
  )
  check_environment(cache, allow_null = TRUE, call = .call)

  elem <- list(
    unit_log_fn = unit_log_fn,
    n_dim = n_dim,
    max_loop = max_loop,
    cache = cache %||% new_environment()
  )

  new_elem <- list2(...)
  check_unique_names(elem, new_elem)
  structure(
    c(elem, new_elem),
    class = c(.class, "ernest_lrps")
  )
}

#' Format method for ernest_lrps
#' @param x An `ernest_lrps`
#' @param ... Ignored.
#' @returns A string
#' @noRd
#' @export
format.ernest_lrps <- function(x, ...) {
  cli::cli_format_method({
    cli::cli_h3("Abstract LRPS")
    cli::cli_text("# Dimensions: {x$n_dim %||% 'Uninitialized'}")
    cli::cli_text("# Calls Since Update: {x$cache$n_call %||% 0L}")
  })
}

#' Print method for ernest_lrps
#' @param x An `ernest_lrps`
#' @param ... Ignored.
#' @returns x, invisibly
#' @noRd
#' @export
print.ernest_lrps <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
  invisible(x)
}

#' Generate a new point using LRPS
#'
#' @description
#' A developer facing function, only used if you are creating your own
#' [ernest_lrps] subclass.
#'
#' When specifying your subclass, you must subclass this
#' this method to specify how your sampler generates new points that satisfy
#' the likelihood constraint.
#'
#' @param x (ernest_lrps) An `ernest_lrps` object.
#' @param original (double vector or matrix, optional) Points within the prior
#' space that are used to start the proposal process. If `NULL`, a new point is
#' generated by sampling from the unconstrained uniform unit cube as in
#' [unif_cube()].
#' @param criteria (double vector) A vector of log-likelihood values
#' that the proposed points must satisfy.
#' @param ... Additional arguments passed to subclass methods.
#' @returns Calls to this generic should always return a list with the following
#' elements:
#' * `unit`: A matrix of proposed points in the prior space.
#' * `log_lik`: A numeric vector of log-likelihood values corresponding to the
#'  proposed points.
#' * `n_call`: The number of calls made to the `unit_log_fn` during the proposal
#' process.
#'
#' @keywords internal
#' @export
propose <- function(x, original = NULL, criteria = NULL, ...) {
  UseMethod("propose")
}

#' @noRd
#' @export
propose.ernest_lrps <- function(x, original = NULL, criteria = NULL) {
  if (is.null(original)) {
    UniformCube(
      criteria = criteria,
      unit_log_lik = x$unit_log_fn,
      num_dim = x$n_dim,
      max_loop = x$max_loop
    )
  } else {
    cli::cli_abort("`x` must not be the abstract class {.cls ernest_lrps}.")
  }
}

#' Update an LRPS
#'
#' @description
#' During a nested sampling run, one may seek to update the internal parameters
#' of the LRPS based on the sampler's performance or other criteria. You can set
#' the frequency of these updates is configured by adjusting the `first_update`
#' and `update_interval` arguments of [nested_sampling()].
#'
#' If you are creating your own subclass of [ernest_lrps], you can subclass this
#' method to specify any special update behaviour. The default method simply
#' reconstructs the LRPS with the current parameters and resets the likelihood
#' call counter in the cache.
#'
#' @param x (ernest_lrps) An `ernest_lrps` object.
#' @returns An updated `ernest_lrps` object with the same class as `x`, but
#' perhaps with updated parameters.
#' @keywords internal
#' @export
update_lrps <- function(x) {
  UseMethod("update_lrps")
}

#' @rdname update_lrps
#' @export
update_lrps.ernest_lrps <- function(x) {
  if (env_has(x$cache, "n_call")) {
    x$cache$n_call <- 0L
  }
  do.call(new_ernest_lrps, as.list(x))
}
