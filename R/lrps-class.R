#' Create a new likelihood-restricted prior sampler (LRPS)
#'
#' @description
#' Nested sampling relies on generating a series of points in the prior space
#' with increasing log-likelihood values. This is accomplished using a
#' likelihood-restricted prior sampler (LRPS), which generates independent and
#' identically distributed points from the prior, subject to a hard likelihood
#' constraint.
#'
#' To create your own LRPS, subclass `new_ernest_lrps` and provide S3 methods
#' for [propose()] and [update_lrps()] for your subclass.
#'
#' @param unit_log_fn,n_dim Provided when [ernest_sampler()] is called with a
#'   given `ernest_lrps`:
#'   * `unit_log_fn` (function, optional): Takes a matrix of points in the unit
#'     cube and returns a numeric vector of log-likelihood values.
#'   * `n_dim` (integer, optional): Number of dimensions of the prior space.
#' @param max_loop Positive integer. Maximum number of attempts to generate
#'   points via region-based sampling. Usually hidden from users, but can be set
#'   via the `ernest.max_loop` option.
#' @param cache (environment, optional) Environment for caching values. If
#'   `NULL`, a new environment is created.
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Name-value pairs for
#'   additional elements for subclasses of this LRPS.
#' @param .class (character vector, optional) Subclasses of this LRPS.
#' @inheritParams rlang::check_exclusive
#'
#' @srrstats {G2.4, G2.4a, G2.4b} Explicit conversion of inputs to expected
#' types or error messages.
#'
#' @returns An LRPS specification: a list containing the input arguments, with a
#' class specific to the LRPS type.
#' @aliases ernest_lrps
#' @keywords internal
#' @export
new_ernest_lrps <- function(
  unit_log_fn = NULL,
  n_dim = NULL,
  max_loop = getOption("ernest.max_loop", 1e6L),
  cache = NULL,
  ...,
  .class = NULL,
  .call = caller_env()
) {
  check_function(unit_log_fn, allow_null = TRUE, call = .call)
  check_number_whole(n_dim, min = 1, allow_null = TRUE, call = .call)
  check_number_whole(
    max_loop,
    min = 1,
    allow_infinite = FALSE,
    arg = "getOption('ernest.max_loop')",
    call = .call
  )
  check_environment(cache, allow_null = TRUE, call = .call)

  elem <- list(
    unit_log_fn = unit_log_fn,
    n_dim = if (is.null(n_dim)) NULL else as.integer(n_dim),
    max_loop = as.integer(max_loop),
    cache = cache %||% new_environment()
  )
  env_cache(elem$cache, "n_call", 0L)
  if (isTRUE(getOption("ernest_logging", FALSE))) {
    logfile <- set_logging(elem$cache)
    if (!isFALSE(logfile)) {
      env_poke(elem$cache, "logfile", logfile)
      cli::cli_alert_success("Log file at {.file {logfile}}.")
    }
  }

  new_elem <- list2(...)
  check_unique_names(elem, new_elem)
  structure(
    c(elem, new_elem),
    class = c(.class, "ernest_lrps")
  )
}

#' @noRd
#' @export
format.ernest_lrps <- function(x, ...) {
  cli::cli_format_method({
    cli::cli_alert_warning("An abstract LRPS sampler {.cls {class(x)}}")
  })
}

#' @noRd
#' @export
print.ernest_lrps <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
  invisible(x)
}

#' Generate a new point using LRPS
#'
#' @description
#' Developer-facing function, used when creating your own [ernest_lrps]
#' subclass.
#'
#' When specifying your subclass, you must implement this method to define how
#' your sampler generates new points that satisfy the likelihood constraint.
#'
#' @param x An `ernest_lrps` object.
#' @param original (double vector or matrix, optional) Points in the prior space
#'   used to start the proposal process. If `NULL`, a new point is generated by
#'   sampling from the unconstrained unit cube (see [unif_cube()]).
#' @param criteria (double scalar) A log-likelihood value that proposed points
#'   must satisfy.
#'
#' @returns A list with:
#' * `unit`: Matrix of proposed points in the prior space.
#' * `log_lik`: Numeric vector of log-likelihood values for the proposed
#' points.
#' * `n_call`: Number of calls made to `unit_log_fn` during the proposal.
#'
#' @keywords internal
#' @export
propose <- function(x, original = NULL, criteria = -Inf) {
  check_number_decimal(criteria)
  UseMethod("propose")
}

#' @noRd
#' @export
propose.ernest_lrps <- function(x, original = NULL, criteria = -Inf) {
  if (is.null(original)) {
    res <- CubeImpl(
      n_dim = x$n_dim,
      unit_log_fn = x$unit_log_fn,
      criterion = criteria,
      max_loop = x$max_loop
    )
    if (isTRUE(getOption("ernest_logging", FALSE))) {
      log4r::debug(
        x$cache$logger,
        method = "unif",
        original = -1,
        new = res$unit,
        ncall = res$n_call
      )
    }
    res
  } else {
    cli::cli_abort("`x` must not be the abstract class {.cls ernest_lrps}.")
  }
}

#' Update an LRPS
#'
#' @description
#' During a nested sampling run, you may wish to update the internal parameters
#' of the LRPS based on sampler performance or other criteria. The frequency of
#' these updates is set by the `first_update` and `update_interval` arguments of
#' [ernest_sampler()].
#'
#' If you are creating your own [ernest_lrps] subclass, implement this method to
#' specify any special update behaviour. The default method reconstructs the
#' LRPS with current parameters and resets the likelihood call counter in the
#' cache.
#'
#' @param x An `ernest_lrps` object.
#' @param unit A matrix of live points within the sampler. If NULL, no LRPS
#' updates based on the state of the live points will be made.
#'
#' @returns An updated `ernest_lrps` object with the same class as `x`, possibly
#' with updated parameters.
#' @keywords internal
#' @export
update_lrps <- function(x, unit = NULL) {
  UseMethod("update_lrps")
}

#' @noRd
#' @export
update_lrps.ernest_lrps <- function(x, unit = NULL) {
  env_poke(x$cache, "n_call", 0L)
  do.call(new_ernest_lrps, as.list(x))
}
