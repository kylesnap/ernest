#' Create a new likelihood-restricted prior sampler (LRPS)
#'
#' @description
#' Nested sampling relies on generating a series of points in the prior space
#' with increasing log-likelihood values. This is accomplished using a
#' likelihood-restricted prior sampler (LRPS), which generates independent and
#' identically distributed points from the prior, subject to a hard likelihood
#' constraint.
#'
#' To create your own LRPS, subclass `new_ernest_lrps` and provide S3 methods
#' for [propose()] and [update_lrps()] for your subclass.
#'
#' @param unit_log_fn,n_dim Provided when [ernest_sampler()] is called with a
#'   given `ernest_lrps`:
#'   * `unit_log_fn` (function, optional): Takes a matrix of points in the unit
#'     cube and returns a numeric vector of log-likelihood values.
#'   * `n_dim` (integer, optional): Number of dimensions of the prior space.
#' @param max_loop Positive integer. Maximum number of attempts to generate
#'   points via region-based sampling. Usually hidden from users, but can be set
#'   via the `ernest.max_loop` option.
#' @param cache (environment, optional) Environment for caching values. If
#'   `NULL`, a new environment is created.
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Name-value pairs for
#'   additional elements for subclasses of this LRPS.
#' @param .class (character vector, optional) Subclasses of this LRPS.
#' @inheritParams rlang::check_exclusive
#'
#' @srrstats {G2.4, G2.4a, G2.4b} Explicit conversion of inputs to expected
#' types or error messages.
#'
#' @returns An LRPS specification: a list containing the input arguments, with a
#' class specific to the LRPS type.
#' @aliases ernest_lrps
#' @keywords internal
#' @export
new_ernest_lrps <- function(
  unit_log_fn = NULL,
  n_dim = NULL,
  max_loop = getOption("ernest.max_loop", 1e6L),
  cache = NULL,
  ...,
  .class = NULL,
  .call = caller_env()
) {
  check_function(unit_log_fn, allow_null = TRUE, call = .call)
  check_number_whole(n_dim, min = 1, allow_null = TRUE, call = .call)
  check_number_whole(
    max_loop,
    min = 1,
    allow_infinite = FALSE,
    arg = "getOption('ernest.max_loop')",
    call = .call
  )
  check_environment(cache, allow_null = TRUE, call = .call)

  elem <- list(
    unit_log_fn = unit_log_fn,
    n_dim = if (is.null(n_dim)) NULL else as.integer(n_dim),
    max_loop = as.integer(max_loop),
    cache = cache %||% new_environment()
  )
  env_poke(elem$cache, "neval", 0L)

  new_elem <- list2(...)
  check_unique_names(elem, new_elem)
  structure(
    c(elem, new_elem),
    class = c(.class, "ernest_lrps")
  )
}

#' @noRd
#' @export
format.ernest_lrps <- function(x, ...) "Abstract"

#' @noRd
#' @export
print.ernest_lrps <- function(x, ...) {
  cli::cli_text("{format(x)}:")

  cli::cli_par()
  cli::cli_text("# Dimensions: {x$n_dim %||% 'Uninitialized'}")
  cli::cli_text("# Calls since last update: {env_get(x$cache, 'neval', 0)}")
  cli::cli_end()
  invisible(x)
}

#' Generate a new point using LRPS
#'
#' @description
#' Developer-facing function, used when creating your own [ernest_lrps]
#' subclass.
#'
#' When specifying your subclass, you must implement this method to define how
#' your sampler generates new points that satisfy the likelihood constraint.
#'
#' @param x An `ernest_lrps` object.
#' @param original Optional double vector. Points in the prior space used to
#' start the proposal process. If `NULL`, a new point is generated by
#' sampling from the unconstrained unit cube (see [unif_cube()]).
#' @param criterion Double scalar. A log-likelihood value that proposed points
#' must satisfy.
#'
#' @returns A list with:
#' * `unit`: Matrix of proposed points in the prior space.
#' * `log_lik`: Numeric vector of log-likelihood values for the proposed
#' points.
#' * `neval`: Number of calls made to `unit_log_fn` during the proposal.
#'
#' @keywords internal
#' @export
propose <- function(x, original = NULL, criterion = -Inf) {
  UseMethod("propose")
}

#' @noRd
#' @export
propose.ernest_lrps <- function(
  x,
  original = NULL,
  criterion = -Inf
) {
  if (is.null(original)) {
    propose_cube(
      unit_log_fn = x$unit_log_fn,
      criterion = criterion,
      n_dim = x$n_dim,
      max_loop = x$max_loop
    )
  } else {
    cli::cli_abort("`x` must not be the abstract class {.cls ernest_lrps}.")
  }
}

#' Generate a new point in a unit cube
#'
#' @param unit_log_fn Function to compute log-likelihood in unit space.
#' @param criterion Double scalar. A log-likelihood value that proposed points
#' must satisfy.
#' @param n_dim Integer. Number of dimensions.
#' @param p The p-norm to sample from.
#' @param max_loop Positive integer. Maximum number of attempts to generate
#' a point.
#'
#' @returns A list with:
#' * `unit`: Vector of proposed points in the prior space.
#' * `log_lik`: Numeric vector of log-likelihood values for the proposed.
#' * `neval`: Number of calls made to `unit_log_fn` during the proposal.
#' @noRd
propose_cube <- function(unit_log_fn, criterion, n_dim, max_loop) {
  proposal <- double(n_dim)
  for (i in seq_len(max_loop)) {
    proposal <- stats::runif(n_dim)
    log_lik <- unit_log_fn(proposal)
    if (is.finite(log_lik) && log_lik > criterion) {
      return(list(
        unit = proposal,
        log_lik = log_lik,
        neval = i
      ))
    }
  }
  list(unit = NULL, log_lik = NULL, neval = max_loop)
}

#' Update an LRPS
#'
#' @description
#' During a nested sampling run, you may wish to update the internal parameters
#' of the LRPS based on sampler performance or other criterion. The frequency of
#' these updates is set by the `first_update` and `update_interval` arguments of
#' [ernest_sampler()].
#'
#' If you are creating your own [ernest_lrps] subclass, implement this method to
#' specify any special update behaviour. The default method reconstructs the
#' LRPS with current parameters and resets the likelihood call counter in the
#' cache.
#'
#' @param x An `ernest_lrps` object.
#' @param unit A matrix of live points within the sampler. If NULL, no LRPS
#' updates based on the state of the live points will be made.
#' @param log_volume The current log-volume of the nested sampling run.
#'
#' @returns An updated `ernest_lrps` object with the same class as `x`, possibly
#' with updated parameters.
#' @keywords internal
#' @export
update_lrps <- function(x, ...) {
  UseMethod("update_lrps")
}

#' @noRd
#' @export
update_lrps.ernest_lrps <- function(x, unit = NULL, ...) {
  env_poke(x$cache, "neval", 0L)
  do.call(new_ernest_lrps, as.list(x))
}
