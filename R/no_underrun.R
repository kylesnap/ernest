#' Generate samples with the No-Underrun Sampler (NURS)
#'
#' @description
#' `r lifecycle::badge("experimental")`
#' Propose points using a modified version
#' of the No-Underrun Sampler (NURS), a gradient-free variant of the No-U-Turn
#' Sampler (NUTS). Samples are generated by defining a line through an initial
#' live point and drawing candidates from a lattice along this line.
#'
#' @param adaptive_scale,fixed_scale Choose one:
#' - `adaptive_scale`: Number between 0 and 1. Updates the width of the sampling
#'   lattice based on quantiles of inter-point distances.
#' - `fixed_scale`: Positive number. Sets the width of the sampling lattice,
#'   which remains constant throughout sampling.
#' @param steps Positive integer. Number of steps to take when generating a
#' proposal point.
#' @param max_orbits Positive integer. Controls the maximum size of the orbit
#' lattice built by the sampler (`2 ^ max_orbits`).
#'
#' @returns An object of class `c("nurs", "ernest_lrps")` for use with
#' [ernest_sampler()] to specify sampling behaviour.
#'
#' @details
#' The No-Underrun Sampler (NURS) is a gradient-free Markov chain Monte Carlo
#' method, related to both Hit-and-Run and No-U-Turn Samplers. This function
#' adapts NURS for likelihood-restricted prior sampling, ensuring all samples
#' meet a minimum likelihood criterion.
#'
#' For each `steps` of the algorithm, we do the following:
#' 1. From the current live point \eqn{x_0}, sample a direction \eqn{\rho} from
#'    the unit hypersphere, defining a line through \eqn{x_0}.
#' 2. Propose an initial shift along this line by a distance
#'    \eqn{U[-h/2, h/2]}, where \eqn{h} is the current lattice scale. Accept if
#'    the shifted point meets the likelihood criterion \eqn{c}.
#' 3. Generate an orbit of points around the shifted \eqn{x_0} as a lattice
#'    with spacing \eqn{h}, using a doubling procedure. Stop if (a) the orbit
#'    exceeds the unit hypercube, or (b) the recursive condition
#'    \deqn{max(l_{left}, l_{right}) < c} fails, where \eqn{l_{left}} and
#'    \eqn{l_{right}} are the likelihoods at the lattice ends.
#' 4. Randomly select one point from the final lattice as the new live point.
#'
#' Choose `fixed_scale` to keep \eqn{h} constant, or `adaptive_scale` to update
#' \eqn{h} from inter-point distances. See References for details on tuning.
#'
#' @inheritSection mini_balls Status
#'
#' @references
#' Bou-Rabee, N., Carpenter, B., Liu, S., & OberdÃ¶rster, S. (2025). The
#' No-Underrun Sampler: A Locally-Adaptive, Gradient-Free MCMC Method
#' (Version 2). arXiv. \doi{10.48550/ARXIV.2501.18548}
#'
#' @examples
#' # Basic usage with default parameters
#' lrps <- no_underrun(adaptive_scale = 0.01)
#'
#' # Conservative settings for difficult problems
#' robust_lrps <- no_underrun(
#'   fixed_scale = 0.01,
#'   steps = 5
#' )
#'
#' @family ernest_lrps
#' @keywords internal
#' @export
no_underrun <- function(
  adaptive_scale,
  fixed_scale,
  steps = 3,
  max_orbits = 8L
) {
  arg <- check_exclusive(adaptive_scale, fixed_scale)
  if (arg == "adaptive_scale") {
    fixed_scale <- NULL
  } else {
    adaptive_scale <- NULL
  }
  new_no_underrun(
    adaptive_scale = adaptive_scale,
    fixed_scale = fixed_scale,
    steps = steps,
    max_orbits = max_orbits
  )
}

#' @noRd
#' @export
format.no_underrun <- function(x, ...) {
  scale_str <- if (is.null(x$adaptive_scale)) {
    "Fixed"
  } else {
    "Adaptive"
  }
  glue::glue(
    "{format.ernest_lrps(x)}",
    "No. Steps: {x$steps}",
    "Scaling Method: {scale_str}",
    "Current Scale: {pretty(x$cache$epsilon %||% 1)}",
    .sep = "\n"
  )
}

#' Create a new adaptive_rwmh LRPS
#'
#' Internal constructor for the adaptive random walk Metropolis-Hastings LRPS.
#'
#' @param unit_log_fn Function for computing log-likelihood in unit space.
#' @param n_dim Integer. Number of dimensions.
#' @param max_loop Integer. Maximum number of proposal attempts.
#' @param cache Optional cache environment.
#' @param steps Integer. Number of steps in the random walk.
#' @param relative_scale,absolute_scale Pick one. Adaptive or static
#' scaling for proposals.
#'
#' @return An LRPS specification, a list with class
#' `c("no_underrun", "ernest_lrps")`.
#' @noRd
new_no_underrun <- function(
  unit_log_fn = NULL,
  n_dim = NULL,
  max_loop = 1e6L,
  cache = NULL,
  steps = 3L,
  adaptive_scale = NULL,
  fixed_scale = NULL,
  max_orbits = 8L
) {
  if (is.null(adaptive_scale) && is.null(fixed_scale)) {
    rlang::abort("One of `adaptive_scale` or `fixed_scale` must be provided.")
  }
  check_number_decimal(adaptive_scale, min = 0, max = 1, allow_null = TRUE)
  check_number_decimal(fixed_scale, allow_null = TRUE)
  if (!is.null(fixed_scale) && fixed_scale <= 0) {
    cli::cli_abort("`fixed_scale` must be larger than 0.")
  }
  check_number_whole(steps, min = 1)
  check_number_whole(max_orbits, min = 1)
  if (!is.null(adaptive_scale)) {
    adaptive_scale <- as.double(adaptive_scale)
  }
  if (!is.null(fixed_scale)) {
    fixed_scale <- as.double(fixed_scale)
  }

  cache <- cache %||% new_environment()
  if (!is.null(fixed_scale)) {
    env_poke(cache, "epsilon", fixed_scale)
  } else {
    env_cache(cache, "epsilon", adaptive_scale)
  }
  env_poke(cache, "n_cmp", 0L)
  env_poke(cache, "n_accept", 0L)

  new_ernest_lrps(
    unit_log_fn = unit_log_fn,
    n_dim = n_dim,
    max_loop = max_loop,
    cache = cache,
    adaptive_scale = adaptive_scale,
    fixed_scale = fixed_scale,
    steps = as.integer(steps),
    max_orbits = as.integer(max_orbits),
    .class = "no_underrun"
  )
}

#' @rdname propose
#' @export
propose.no_underrun <- function(
  x,
  original = NULL,
  criterion = -Inf
) {
  if (is.null(original)) {
    NextMethod(x)
  } else {
    res <- NURSImpl(
      original = original,
      unit_log_fn = x$unit_log_fn,
      criterion = criterion,
      steps = x$steps,
      h = x$cache$epsilon,
      M = x$max_orbits
    )
    env_poke(x$cache, "n_call", x$cache$n_call + res$n_call)
    env_poke(x$cache, "n_cmp", x$cache$n_cmp + res$n_candidates)
    env_poke(x$cache, "n_accept", x$cache$n_accept + res$n_jump)
    res
  }
}

#' @rdname update_lrps
#' @export
update_lrps.no_underrun <- function(x, unit = NULL, ...) {
  if (is.null(unit) || is.null(x$adaptive_scale)) {
    return(do.call(new_no_underrun, as.list(x)))
  }

  try_fetch(
    {
      dist <- stats::dist(unit)
      new_ep <- as.double(stats::quantile(dist, x$adaptive_scale))
      if (!is_scalar_double(new_ep) || is.na(new_ep) || !is.finite(new_ep)) {
        cli::cli_abort(
          "`epsilon` must be a finite scalar double, not {new_ep}."
        )
      }
      env_poke(x$cache, "epsilon", new_ep)
    },
    error = function(cnd) {
      cli::cli_warn("Failed to update lattice scale.", parent = cnd)
      env_unbind(x$cache, "epsilon")
    }
  )
  do.call(new_no_underrun, as.list(x))
}
