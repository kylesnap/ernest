#' Plot diagnostics for a nested sampling run
#'
#' Visualizes key diagnostics from a nested sampling run, including the
#' normalized likelihood, posterior weights, and evidence as functions
#' of log-prior volume.
#'
#' @param x [[ernest_run]] or [[ernest_estimate]]\cr An object containing
#' results from nested sampling.
#' @param which `[character()]`\cr Choose which plots to display. Must be one
#' or more of `"evidence"`, `"weight"`, and `"likelihood"`.
#' @inheritParams rlang::args_dots_empty
#'
#' @returns `[invisible(x)]`. A `ggplot2::ggplot()` object is printed as a
#' side effect.
#'
#' @details
#' Interpreting these plots can help diagnose issues such as poor or
#' insufficient prior sampling and model misspecification. Use `which` to select
#' the plots to display:
#'
#' * `which = "evidence"`: Plots the estimated marginal
#' likelihood (evidence) as a function of log-prior volume, with uncertainty
#' intervals. Peaks in this plot indicate regions of prior volume that
#' contribute most to the evidence estimate.
#' * `which = "weight"`: Shows the distribution of
#' posterior mass across log-prior volume. This plot highlights which regions
#' of the prior volume contain the most posterior probability, helping to
#' identify where the sampler concentrated its effort.
#' * `which = "likelihood"`: Displays the normalized
#' likelihood as a function of log-prior volume. Smoothness in this plot
#' indicates effective likelihood-restricted prior sampling, while
#' irregularities may suggest sampling difficulties or, in some cases,
#' misspecified likelihood functions.
#'
#' If `x` is an `ernest_run`, the plots are based on the actual run data. Error
#' ribbons are drawn around the `evidence` plot from analytic estimates of
#' uncertainty (see {summary.ernest_run}).
#'
#' If `x` is an `ernest_estimate` (or if `ndraws` is specified), the plots
#' are based on simulated values from the log-volume. The highest density
#' continuous intervals (HDCIs) are computed using [ggdist::median_hdci()] for
#' both the `evidence` and `weight` plots.
#'
#' @note
#' Plotting multiple diagnostics with `which` requires the patchwork package.
#' Plotting `ernest_estimate` objects requires the ggdist package.
#'
#' @srrstats {BS6.1} Default plot for return object.
#'
#' @seealso
#' * [calculate()] for generating `ernest_estimate` objects.
#' * [visualize()] for plotting the posterior distributions generated by a run.
#'
#' @examples
#' # Plot results from a run.
#' data(example_run)
#' plot(example_run)
#'
#' # Simulate results before plotting.
#' set.seed(42)
#' plot(example_run, ndraws = 100)
#'
#' # Equivalently, simulate results, then plot:
#' set.seed(123)
#' est <- calculate(example_run, ndraws = 100)
#' plot(est)
#' @rdname plot.ernest_run
#' @export
plot.ernest_estimate <- function(
  x,
  which = c("evidence", "weight", "likelihood"),
  ...
) {
  check_dots_empty()
  which <- arg_match(
    which,
    values = c("evidence", "weight", "likelihood"),
    multiple = TRUE
  )
  if (length(which) == 0) {
    cli::cli_abort("At least one plot type must be specified in `which`.")
  } else if (length(which) > 0) {
    check_required("patchwork", "to combine multiple plots")
  }
  check_required("ggdist", "to calculate HDCIs")
  print(autoplot(x, which, ...))
}

#' @inheritParams calculate.ernest_run
#'
#' @rdname plot.ernest_run
#' @export
plot.ernest_run <- function(
  x,
  which = c("evidence", "weight", "likelihood"),
  ndraws = NULL,
  ...
) {
  which <- arg_match(
    which,
    values = c("evidence", "weight", "likelihood"),
    multiple = TRUE
  )
  if (length(which) == 0) {
    cli::cli_abort("At least one plot type must be specified in `which`.")
  } else if (length(which) > 0) {
    check_required("patchwork", "to combine multiple plots")
  }
  if (!is.null(ndraws)) {
    x <- calculate(x, ndraws = ndraws)
  }
  print(autoplot(x, which, ...))
}

# AUTOPLOT METHODS -----

#' Generates a ggplot object for an `ernest_estimate` object containing
#' uncertainty simulations.
#'
#' @param object An `ernest_estimate` object containing uncertainty simulations.
#' @param which Which plots to display.
#' @param call The calling environment for error handling.
#' @param ... Additional arguments passed to the method.
#'
#' @return A ggplot object.
#' @noRd
#' @importFrom ggplot2 autoplot
#' @export
autoplot.ernest_estimate <- function(object, which, call = caller_env(), ...) {
  check_dots_empty()
  multi_plot <- length(which) > 1

  # Generate evidence and weight matrices
  log_evidence <- posterior::draws_of(object$log_evidence)
  log_weights <- posterior::draws_of(object$log_weight)
  evidence <- exp(log_evidence)
  weights <- exp(sweep(
    log_weights,
    1,
    log_evidence[, ncol(log_evidence)],
    FUN = "-"
  ))
  log_volume <- posterior::draws_of(object$log_volume)

  n_bins <- 512
  rng <- attr(object, "log_vol_rng")
  breaks <- seq(rng[2], rng[1], length.out = n_bins)
  log_volume <- posterior::draws_of(object$log_volume)
  dead_log_vol <- attr(object, "dead_log_vol")

  z_p <- if ("evidence" %in% which) {
    df <- approx_over_vol(log_volume, evidence, breaks)
    autoplot_errors(df, "HDCI", "Evidence", dead_log_vol)
  } else {
    NULL
  }
  w_p <- if ("weight" %in% which) {
    df <- density_over_vol(log_volume, weights, breaks, rng)
    autoplot_errors(df, "HDCI", "Posterior Weight", dead_log_vol)
  }
  l_p <- if ("likelihood" %in% which) {
    log_lik <- posterior::draws_of(object$log_lik)[1, ]
    df <- tibble::tibble(
      "log_volume" = mean(object$log_volume),
      "y" = exp(log_lik - max(log_lik))
    )
    autoplot_line(df, "Normalized Likelihood", dead_log_vol)
  } else {
    NULL
  }

  if (multi_plot) {
    patchwork::wrap_plots(
      list(z_p, w_p, l_p)[c("evidence", "weight", "likelihood") %in% which],
      ncol = 1,
      axis_titles = "collect"
    )
  } else {
    if ("evidence" %in% which) {
      z_p
    } else if ("weight" %in% which) {
      w_p
    } else {
      l_p
    }
  }
}

#' Generates a ggplot object for an `ernest_run` object containing a nested
#' sampling run.
#'
#' @param object Results from a nested sampling run.
#' @param which Which plots to display.
#' @param call The calling environment for error handling.
#' @param ... Additional arguments passed to the method.
#'
#' @return A ggplot object.
#' @noRd
#' @export
autoplot.ernest_run <- function(object, which, call = caller_env(), ...) {
  check_dots_empty()
  log_vol <- drop(get_logvol(object$nlive, niter = object$niter))
  integration <- compute_integral(object$weights$log_lik, log_vol)
  dead_log_vol <- log_vol[object$niter]

  z_p <- if ("evidence" %in% which) {
    log_evidence_sd <- sqrt(integration$log_evidence_var)
    df_66 <- tibble::tibble(
      "log_volume" = integration$log_volume,
      "y" = exp(integration$log_evidence),
      "ymin" = exp(integration$log_evidence - 1 * log_evidence_sd),
      "ymax" = exp(integration$log_evidence + 1 * log_evidence_sd),
      ".width" = 0.66
    )
    df_95 <- tibble::tibble(
      "log_volume" = integration$log_volume,
      "y" = exp(integration$log_evidence),
      "ymin" = exp(integration$log_evidence - 2 * log_evidence_sd),
      "ymax" = exp(integration$log_evidence + 2 * log_evidence_sd),
      ".width" = 0.95
    )
    df <- rbind(df_66, df_95)
    autoplot_errors(df, "CI", "Evidence", dead_log_vol)
  } else {
    NULL
  }
  w_p <- if ("weight" %in% which) {
    weights <- exp(
      integration$log_weight -
        integration$log_evidence[length(integration$log_evidence)]
    )
    dens <- stats::density(
      integration$log_volume,
      weights = weights,
      warnWbw = FALSE
    )
    df <- tibble::tibble(
      "log_volume" = dens$x,
      "y" = dens$y
    )
    autoplot_line(df, "Posterior Weight", dead_log_vol)
  } else {
    NULL
  }
  l_p <- if ("likelihood" %in% which) {
    lik <- exp(integration$log_lik - max(integration$log_lik))
    df <- tibble::tibble(
      "log_volume" = integration$log_volume,
      "y" = lik
    )
    autoplot_line(df, "Normalized Likelihood", dead_log_vol)
  } else {
    NULL
  }

  if (length(which) > 1) {
    patchwork::wrap_plots(
      list(z_p, w_p, l_p)[c("evidence", "weight", "likelihood") %in% which],
      ncol = 1,
      guides = "collect"
    )
  } else {
    if ("evidence" %in% which) {
      z_p
    } else if ("weight" %in% which) {
      w_p
    } else {
      l_p
    }
  }
}

#' Internal helper to plot error ribbons (HDCI or CI) for diagnostics
#' over log-prior volume.
#'
#' @param df Data frame containing columns `log_volume`, `y`, `ymin`,
#' `ymax`, and `.width`.
#' @param fill_name,y_name Name for the fill legend and y-axis.
#' @param xintercept Optional value for a vertical reference line.
#'
#' @return A ggplot object with ribbons and line.
#' @noRd
#' @importFrom ggplot2 ggplot aes geom_line geom_ribbon geom_vline
#' @importFrom ggplot2 scale_fill_brewer scale_x_continuous scale_y_continuous
#' @importFrom ggplot2 theme_minimal
autoplot_errors <- function(df, fill_name, y_name, xintercept = NULL) {
  df$.width <- factor(df$.width, levels = c("0.95", "0.66"), ordered = TRUE)
  ggplot(df, aes(.data[["log_volume"]], y = .data[["y"]])) +
    geom_ribbon(
      aes(
        ymin = .data[["ymin"]],
        ymax = .data[["ymax"]],
        fill = .data[[".width"]]
      )
    ) +
    geom_line() +
    geom_vline(xintercept = xintercept, linetype = 2) +
    scale_fill_brewer(fill_name, palette = "Reds") +
    scale_x_continuous("Log-volume") +
    scale_y_continuous(y_name) +
    theme_minimal()
}

#' Internal helper to plot a single line for a diagnostic.
#'
#' @param df Data frame with columns `log_volume` and `y`.
#' @param y_name Name for the y-axis.
#' @param xintercept Optional value for a vertical reference line.
#'
#' @return A ggplot object with a line.
#' @noRd
autoplot_line <- function(df, y_name, xintercept = NULL) {
  ggplot(df, aes(x = .data[["log_volume"]], y = .data[["y"]])) +
    geom_line() +
    geom_vline(xintercept = xintercept, linetype = 2) +
    scale_x_continuous("Log-volume") +
    scale_y_continuous(y_name) +
    theme_minimal()
}

#' Interpolate diagnostic values over log-prior volume
#'
#' @param log_volume Matrix of log-prior volumes (draws x steps).
#' @param y Matrix of diagnostic values (draws x steps).
#' @param breaks Numeric vector of breakpoints along `log_volume` for
#' interpolation.
#'
#' @return Tibble with interpolated values and HDCIs.
#' @noRd
approx_over_vol <- function(log_volume, y, breaks) {
  approx <- vapply(
    seq_len(nrow(log_volume)),
    \(i) {
      stats::approx(
        x = log_volume[i, ],
        y = y[i, ],
        xout = breaks,
        rule = 2
      )$y
    },
    double(length(breaks))
  )
  approx <- matrix(
    approx,
    nrow = nrow(log_volume),
    ncol = length(breaks),
    byrow = TRUE
  )
  hdi <- do.call(
    rbind,
    apply(approx, 2, \(row) ggdist::mean_hdci(row, .width = c(.66, .95)))
  )
  tibble::tibble("log_volume" = rep(breaks, each = 2), !!!hdi)
}

#' Internal helper to estimate the density of posterior weights over
#' log-prior volume.
#'
#' @param log_volume Matrix of log-prior volumes (draws x steps).
#' @param weights Matrix of normalized weights (draws x steps).
#' @param breaks Numeric vector of breakpoints for interpolation.
#' @param bounds Numeric vector of lower and upper bounds for log-prior volume.
#'
#' @return Tibble with estimated densities and HDCIs.
#' @noRd
density_over_vol <- function(log_volume, weights, breaks, bounds) {
  approx <- vapply(
    seq_len(nrow(log_volume)),
    \(i) {
      idx <- which(log_volume[i, ] > bounds[1])
      ggdist::density_bounded(
        x = log_volume[i, idx],
        weights = weights[i, idx],
        bounds = c(bounds[1], 0),
        n = 512
      )$y |>
        rev()
    },
    double(512)
  )
  approx <- matrix(
    approx,
    nrow = nrow(log_volume),
    ncol = 512,
    byrow = TRUE
  )
  hdi <- do.call(
    rbind,
    apply(approx, 2, \(row) {
      ggdist::mean_hdci(row, .width = c(.66, .95))
    })
  )
  tibble::tibble("log_volume" = rep(breaks, each = 2), !!!hdi)
}
