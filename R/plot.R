#' Plot diagnostics for a nested sampling run
#'
#' Shows the normalised likelihood, importance weights, and evidence as
#' functions of log-volume.
#'
#' @param x An [ernest_estimate] or [ernest_run] object.
#' @param which An optional character vector, containing any of `evidence`,
#' `weight`, or `likelihood`. Selects the diagnostic plot(s) to produce from `x`
#' (See Details).
#' @inheritParams rlang::args_dots_empty
#'
#' @returns
#' Invisibly returns `x`. A `ggplot2::ggplot()` object is printed as a
#' side effect.
#'
#' @details
#' Produces plots that visualize the relationship between the prior volume and
#' quantities estimated during the run. Use `which` to select the quantities
#' you would like to visualize:
#'
#' - `which = "evidence"` Shows the log-volume regions within a run that
#' contributed the most to the model evidence estimates (and its error);
#' - `which = "weight"` Shows the range of samples within the run that feature
#' points with the most posterior mass.
#' - `which = "likelihood"` Shows how smoothly the sampler generated new points
#' which likelihood-restricted prior sampling (see [ernest_lrps]);
#'
#' If `x` is an `ernest_run`, these estimates are derived from the run;
#' if `x` is an `ernest_estimate` (or `ndraws != 0`), these values are
#' simulated.
#'
#' @note
#' Using `which` with multiple options requires the `patchwork` package to be
#' installed.
#'
#' @srrstats {BS6.1} Default plot for return object.
#'
#' @seealso
#' * [calculate()] for generating `ernest_estimate` objects.
#' * [visualize()] for plotting the posterior distributions generated by a run.
#'
#' @export
#' @examples
#' # Plot integration results from a run.
#' data(example_run)
#' plot(example_run)
#'
#' # Simulate results before plotting.
#' plot(example_run, ndraws = 100)
plot.ernest_estimate <- function(
  x,
  which = c("evidence", "weight", "likelihood"),
  ...
) {
  check_dots_empty()
  print(autoplot(x, which, ...))
}

#' @inheritParams calculate.ernest_run
#'
#' @rdname plot.ernest
#' @export
#' @examples
#' # Simulate results from a run, then plot simulated results.
#' sim <- calculate(example_run, ndraws = 100)
#' plot(sim)
plot.ernest_run <- function(
  x,
  which = c("evidence", "weight", "likelihood"),
  ndraws = NULL,
  ...
) {
  check_dots_empty()
  check_number_whole(ndraws, lower = 1, allow_null = TRUE)
  if (!is.null(ndraws)) {
    x <- calculate(x, ndraws = ndraws)
  }
  print(autoplot(x, which, ...))
}

# AUTOPLOT METHODS -----

#' Autoplot for Ernest Estimates
#'
#' Generates a ggplot object for an `ernest_estimate` object containing
#' uncertainty simulations.
#'
#' @param object An `ernest_estimate` object containing uncertainty simulations.
#' @param ... Additional arguments passed to the method.
#'
#' @return A ggplot object.
#' @noRd
#' @importFrom ggplot2 autoplot
#' @export
autoplot.ernest_estimate <- function(object, which, call = caller_env(), ...) {
  check_dots_empty()
  which <- validate_autoplot_which(which, call = call)
  check_required("ggdist", "to calculate HDCIs")

  multi_plot <- length(which) > 1
  if (multi_plot) {}

  # Generate evidence and weight matrices
  log_evidence <- posterior::draws_of(object$log_evidence)
  log_weights <- posterior::draws_of(object$log_weight)
  evidence <- exp(log_evidence)
  weights <- exp(sweep(
    log_weights,
    1,
    log_evidence[, ncol(log_evidence)],
    FUN = "-"
  ))
  log_volume <- posterior::draws_of(object$log_volume)

  n_bins <- 512
  rng <- attr(object, "log_vol_rng")
  breaks <- seq(rng[2], rng[1], length.out = n_bins)
  log_volume <- posterior::draws_of(object$log_volume)
  dead_log_vol <- attr(object, "dead_log_vol")

  z_p <- if ("evidence" %in% which) {
    df <- approx_over_vol(log_volume, evidence, breaks)
    autoplot_errors(df, "HDCI", "Evidence", dead_log_vol)
  } else {
    NULL
  }
  w_p <- if ("weight" %in% which) {
    df <- density_over_vol(log_volume, weights, breaks, rng)
    autoplot_errors(df, "HDCI", "Posterior Weight", dead_log_vol)
  }
  l_p <- if ("likelihood" %in% which) {
    log_lik <- posterior::draws_of(object$log_lik)[1, ]
    df <- tibble::tibble(
      "log_volume" = mean(object$log_volume),
      "y" = exp(log_lik - max(log_lik))
    )
    autoplot_line(df, "Normalized Likelihood", dead_log_vol)
  } else {
    NULL
  }

  if (multi_plot) {
    patchwork::wrap_plots(
      list(z_p, w_p, l_p)[c("evidence", "weight", "likelihood") %in% which],
      ncol = 1,
      axis_titles = "collect"
    )
  } else {
    if ("evidence" %in% which) {
      z_p
    } else if ("weight" %in% which) {
      w_p
    } else {
      l_p
    }
  }
}

#' Autoplot for Ernest Run Objects
#'
#' Generates a ggplot object for an `ernest_run` object containing a nested
#' sampling run.
#'
#' @param object An `ernest_run` object containing a nested sampling run.
#' @param ... Additional arguments passed to the method.
#'
#' @return A ggplot object.
#' @noRd
#' @export
autoplot.ernest_run <- function(object, which, call = caller_env(), ...) {
  check_dots_empty()
  which <- validate_autoplot_which(which, call = call)
  dead_log_vol <- object$log_volume[object$n_iter]

  z_p <- if ("evidence" %in% which) {
    log_evidence_sd <- sqrt(object$log_evidence_var)
    df_66 <- tibble::tibble(
      "log_volume" = object$log_volume,
      "y" = exp(object$log_evidence),
      "ymin" = exp(object$log_evidence - 1 * log_evidence_sd),
      "ymax" = exp(object$log_evidence + 1 * log_evidence_sd),
      ".width" = 0.66
    )
    df_95 <- tibble::tibble(
      "log_volume" = object$log_volume,
      "y" = exp(object$log_evidence),
      "ymin" = exp(object$log_evidence - 2 * log_evidence_sd),
      "ymax" = exp(object$log_evidence + 2 * log_evidence_sd),
      ".width" = 0.95
    )
    df <- rbind(df_66, df_95)
    autoplot_errors(df, "CI", "Evidence", dead_log_vol)
  } else {
    NULL
  }
  w_p <- if ("weight" %in% which) {
    weights <- exp(
      object$log_weight - object$log_evidence[length(object$log_evidence)]
    )
    dens <- stats::density(
      object$log_volume,
      weights = weights,
      warnWbw = FALSE
    )
    df <- tibble::tibble(
      "log_volume" = dens$x,
      "y" = dens$y
    )
    autoplot_line(df, "Posterior Weight", dead_log_vol)
  } else {
    NULL
  }
  l_p <- if ("likelihood" %in% which) {
    lik <- exp(object$log_lik - max(object$log_lik))
    df <- tibble::tibble(
      "log_volume" = object$log_volume,
      "y" = lik
    )
    autoplot_line(df, "Normalized Likelihood", dead_log_vol)
  } else {
    NULL
  }

  if (length(which) > 1) {
    patchwork::wrap_plots(
      list(z_p, w_p, l_p)[c("evidence", "weight", "likelihood") %in% which],
      ncol = 1,
      guides = "collect"
    )
  } else {
    if ("evidence" %in% which) {
      z_p
    } else if ("weight" %in% which) {
      w_p
    } else {
      l_p
    }
  }
}

validate_autoplot_which <- function(which, call = caller_env()) {
  check_required(which, call = call)
  which <- arg_match(
    which,
    values = c("evidence", "weight", "likelihood"),
    multiple = TRUE,
    error_call = call
  )
  if (length(which) > 0) {
    check_required(
      "patchwork",
      "to plot multiple diagnostic plots",
      call = call
    )
  }
  which
}

#' @importFrom ggplot2 ggplot aes geom_line geom_ribbon geom_vline
#' @importFrom ggplot2 scale_fill_brewer scale_x_reverse scale_y_continuous
#' @importFrom ggplot2 theme_minimal
#' @noRd
autoplot_errors <- function(df, fill_name, y_name, xintercept = NULL) {
  df$.width <- factor(df$.width, levels = c("0.95", "0.66"), ordered = TRUE)
  ggplot(df, aes(log_volume, y = y)) +
    geom_ribbon(
      aes(ymin = ymin, ymax = ymax, fill = .width)
    ) +
    geom_line() +
    geom_vline(xintercept = xintercept, linetype = 2) +
    scale_fill_brewer(fill_name, palette = "Reds") +
    scale_x_reverse("Log. Volume") +
    scale_y_continuous(y_name) +
    theme_minimal()
}

autoplot_line <- function(df, y_name, xintercept = NULL) {
  ggplot(df, aes(x = log_volume, y = y)) +
    geom_line() +
    geom_vline(xintercept = xintercept, linetype = 2) +
    scale_x_reverse("Log. Volume") +
    scale_y_continuous(y_name) +
    theme_minimal()
}

approx_over_vol <- function(log_volume, y, breaks) {
  approx <- vapply(
    seq_len(nrow(log_volume)),
    \(i) {
      stats::approx(
        x = log_volume[i, ],
        y = y[i, ],
        xout = breaks,
        rule = 2
      )$y
    },
    double(length(breaks))
  )
  approx <- matrix(
    approx,
    nrow = nrow(log_volume),
    ncol = length(breaks),
    byrow = TRUE
  )
  hdi <- do.call(
    rbind,
    apply(approx, 2, \(row) ggdist::mean_hdci(row, .width = c(.66, .95)))
  )
  tibble::tibble("log_volume" = rep(breaks, each = 2), !!!hdi)
}

density_over_vol <- function(log_volume, weights, breaks, bounds) {
  approx <- vapply(
    seq_len(nrow(log_volume)),
    \(i) {
      idx <- which(log_volume[i, ] > bounds[1])
      ggdist::density_bounded(
        x = log_volume[i, idx],
        weights = weights[i, idx],
        bounds = c(bounds[1], 0),
        n = 512
      )$y |>
        rev()
    },
    double(512)
  )
  approx <- matrix(
    approx,
    nrow = nrow(log_volume),
    ncol = 512,
    byrow = TRUE
  )
  hdi <- do.call(
    rbind,
    apply(approx, 2, \(row) ggdist::mean_hdci(row, .width = c(.66, .95)))
  )
  tibble::tibble("log_volume" = rep(breaks, each = 2), !!!hdi)
}
