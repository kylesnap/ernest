#' Create a new ernest run object
#' @param x An `ernest_sampler` or `ernest_results` object used to produce a run
#' @param results The list output from nested_sampling_impl.
#' @returns A new ernest_run object.
#' @noRd
new_ernest_run <- function(x, ...) {
  UseMethod("new_ernest_run")
}

#' @method new_ernest_run ernest_sampler
#' @export
new_ernest_run.ernest_sampler <- function(x, results) {
  parsed <- parse_results(results)
  new_ernest_run_(x, parsed)
}

#' @method new_ernest_run ernest_run
#' @export
new_ernest_run.ernest_run <- function(x, results) {
  prev_iter <- x$n_iter
  old_idx <- vctrs::vec_as_location(
    seq(prev_iter),
    vctrs::vec_size(x$log_lik)
  )
  parsed <- parse_results(results)

  parsed$unit <- rbind(x$samples_unit[old_idx, ], parsed$unit)
  parsed$log_lik <- vec_c(x$log_lik[old_idx], parsed$log_lik)
  parsed$id <- vec_c(x$id[old_idx], parsed$id)
  parsed$calls <- vec_c(x$calls[old_idx], parsed$calls)
  parsed$birth <- vec_c(x$birth[old_idx], parsed$birth)
  parsed$n_iter <- x$n_iter + parsed$n_iter
  new_ernest_run_(x, parsed)
}

#' Form the new_ernest_run from samples from the current and previous runs
#' @param x The ernest_run or ernest_sampler object.
#' @param parsed A list with the previous dead points from the run.
#' @returns A new ernest_run object.
#' @noRd
new_ernest_run_ <- function(x, parsed) {
  live_order <- order(x$live_points$log_lik)
  samples_unit <- rbind(parsed$unit, x$live_points$unit[live_order, ])
  colnames(samples_unit) <- x$prior$varnames
  samples <- t(apply(samples_unit, 1, x$prior$fn))
  colnames(samples) <- x$prior$varnames

  live <- list(
    "log_lik" = x$live_points$log_lik[live_order],
    "id" = live_order,
    "birth" = x$live_points$birth[live_order]
  )
  all_samples <- bind_dead_live(parsed, live, x$n_points, parsed$n_iter)

  log_vol <- cumsum(-1 * (all_samples$points**-1))
  integration <- compute_integral(all_samples$log_lik, log_vol)

  result_elem <- list2(
    "n_iter" = parsed$n_iter,
    "n_calls" = sum(all_samples$calls),
    !!!integration,
    "id" = all_samples$id,
    "points" = all_samples$points,
    "calls" = all_samples$calls,
    "birth" = all_samples$birth,
    "samples" = samples,
    "samples_unit" = samples_unit
  )

  sampler_elem <- list(
    log_lik_fn = x$log_lik_fn,
    prior = x$prior,
    lrps = x$lrps,
    n_points = x$n_points,
    first_update = x$first_update,
    update_interval = x$update_interval,
    live_points = x$live_points
  )

  do.call(
    new_ernest_sampler,
    list2(!!!sampler_elem, !!!result_elem, .class = "ernest_run")
  )
}

#' Format method for ernest_run
#' @param x The ernest_run object.
#' @return A formatted string.
#' @noRd
#' @export
format.ernest_run <- function(x, ...) {
  log_z <- tail(x$log_evidence, 1)
  log_z_sd <- sqrt(tail(x$log_evidence_var, 1))
  cli::cli_format_method({
    cli::cli_div(theme = list(.val = list(digits = 3)))
    cli::cli_bullets(c(
      "An {.cls ernest_run}: {x$n_points} points, {x$prior$n_dim} variables",
      "*" = "{x$n_iter} iterations, {x$n_calls} likelihood calls",
      "*" = "Log. Evidence \U2248 {.val {log_z}} (\U00B1 {.val {log_z_sd}})"
    ))
  })
}

#' Print method for ernest_run
#' @param x The ernest_run object.
#' @return Itself, invisibly.
#' @srrstats {BS6.0} Default print for results objects.
#' @noRd
#' @export
print.ernest_run <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
  invisible(x)
}

#' Summarise a nested sampling run
#'
#' Provides a summary of an `ernest_run` object.
#'
#' @param object (ernest_run) An object of class `ernest_run`.
#' @inheritParams rlang::args_dots_empty
#'
#' @return An object of class `summary.ernest_run`, a list with:
#' * `n_iter`: Number of iterations (number of dead points).
#' * `n_points`: Number of live points at the end of the run.
#' * `log_volume`, `log_evidence`, `log_evidence_err`: The final estimates of
#' the quantities performed by the run that generated `object`.
#' * `run`, A tibble with `n_iter + n_points` rows, containing the vectors
#'  `call`, `log_lik`, `log_volume`, `log_weight`, `log_evidence`,
#'  `log_evidence_err`, and `information`.
#'
#' @seealso [ernest_run-class] for the `ernest_run` object. [as_draws()] for
#' how to summarize the posterior distribution generated by nested sampling.
#' @srrstats {BS6.4} Summary method for results object.
#' @method summary ernest_run
#' @export
#' @examples
#' # Load an example run
#' data(example_run)
#'
#' # Summarise the run and view a tibble of its results.
#' run_sm <- summary(example_run)
#' run_sm
#' run_sm$run
summary.ernest_run <- function(object, ...) {
  check_dots_empty()
  log_z_max <- tail(object$log_evidence, 1)

  sum_df <- tibble::tibble(
    "call" = cumsum(object$call),
    "log_lik" = object$log_lik,
    "log_volume" = object$log_volume,
    "log_weight" = object$log_weight - log_z_max,
    "log_evidence" = object$log_evidence,
    "log_evidence_err" = sqrt(object$log_evidence_var),
    "information" = object$information
  )

  structure(
    list(
      "n_iter" = object$n_iter,
      "n_points" = object$n_points,
      "n_calls" = object$n_calls,
      "log_volume" = tail(sum_df$log_volume, 1),
      "log_evidence" = tail(sum_df$log_evidence, 1L),
      "log_evidence_err" = tail(sum_df$log_evidence_err, 1L),
      "run" = sum_df,
      "draws" = as_draws(object)
    ),
    class = "summary.ernest_run"
  )
}

#' Format method for ernest_run summary.
#' @param x The summary.ernest_run object.
#' @return A formatted string.
#' @noRd
#' @export
format.summary.ernest_run <- function(x, ...) {
  log_z <- formatC(x$log_evidence, digits = 4, format = "fg")
  log_z_sd <- formatC(x$log_evidence_err, digits = 4, format = "fg")

  cli::cli_format_method({
    cli::cli_h1("Nested Sampling Results from {.cls ernest_run}")
    cli::cli_dl(c(
      "No. Points" = "{x$n_points}",
      "No. Iterations" = "{x$n_iter}",
      "No. Lik. Calls" = "{x$n_call}",
      "Log. Evidence" = "{log_z} (\U00B1 {log_z_sd})"
    ))
  })
}

#' Format method for ernest_run summary.
#' @param x The summary.ernest_run object.
#' @return x, invisibly.
#' @noRd
#' @export
print.summary.ernest_run <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
  invisible(x)
}

# HELPERS FOR ERNEST_RUN-----

#' Parse the results from nested_sampling_impl into a list
#' @param results Output from nested_sampling_impl
#' @return A named list of vectors and the number of iterations.
#' @noRd
parse_results <- function(results) {
  dead_unit <- do.call(rbind, results$dead_unit)
  dead_log_lik <- list_c(results$dead_log_lik)
  dead_id <- list_c(results$dead_id)
  dead_calls <- list_c(results$dead_calls)
  dead_birth <- list_c(results$dead_birth)
  n_iter <- vctrs::vec_size(dead_log_lik)
  list(
    "unit" = dead_unit,
    "log_lik" = dead_log_lik,
    "id" = dead_id,
    "calls" = dead_calls,
    "birth" = dead_birth,
    "n_iter" = n_iter
  )
}

#' Merge dead and live samples together
#' @param dead The list object from parse_results.
#' @param live The log_lik, id, and birth vectors from the current live points.
#' @param n_iter,n_points The iterations and live points used for the run.
#' @returns A df_list of vectors, that are all of the length n_points + n_iter.
#' @importFrom vctrs vec_c
#' @noRd
bind_dead_live <- function(dead, live, n_points, n_iter) {
  vctrs::df_list(
    "log_lik" = vec_c(dead$log_lik, live$log_lik, .ptype = double()),
    "id" = vec_c(dead$id, live$id, .ptype = integer()),
    # TODO points should be collected as a list of int during the run.
    "points" = vec_c(
      rep(n_points, n_iter),
      seq(n_points, 1),
      .ptype = integer()
    ),
    "calls" = vec_c(dead$calls, rep(0L, n_points), .ptype = integer()),
    "birth" = vec_c(dead$birth, live$birth, .ptype = integer())
  )
}


#' Results from nested sampling runs
#'
#' The `ernest_run` object contains the results of a nested sampling run. It has
#' methods for summary, plotting, and for simulating the uncertainty around the
#' run's estimates.
#'
#' @name ernest_run-class
#' @aliases ernest_run
#' @docType class
#'
#' @slot n_iter Total number of iterations performed.
#' @slot n_points Number of points drawn into the live set.
#' @slot n_calls Number of calls to the log likelihood function.
#' @slot log_lik A vector of log likelihood values associated with each point
#' generated during the run.
#' @slot log_volume A vector of the estimated prior volumes associated with the
#' removal of each point from the live set.
#' @slot log_weight A vector of unnormalized posterior weights for each point.
#' @slot log_evidence A vector of log. evidence estimates, generated after the
#' removal of each point.
#' @slot log_evidence_var A vector of uncertainty values associated with each
#' entry in `log_evidence`. 1.
#' @slot information A vector of the estimated KL-divergence (or information)
#' between the prior and posterior distributions.
#' @slot id The index of each point within the live set.
#' @slot points The number of live points associated with each point's removal.
#' @slot calls The number of likelihood calls made when generating a replacement
#' live point.
#' @slot birth The iteration at which the point was created and added to the
#' live set.
#' @slot samples A matrix of the sampled points, expressed in the units of the
#' prior space.
#' @slot samples_unit Identical to `samples`, but expressed in the units of the
#' 0-1 hypercube.
#' @slot spec A pairlist, describing the `log_lik`, `prior`, `sampler`,
#' `first_update`, `update_interval` used to produce this run, as well as
#' the `min_logz` value the run was terminated on.
#'
#' @srrstats {BS5.0, BS5.1, BS5.2, BS5.3} ernest_run contains the prior
#' specification, log. lik function, and the est. remaining log evidence within
#' the `spec` pairlist. The random seed is also stored as an attribute.
#'
#' @details
#' The `ernest_run` object is returned by running a nested sampling procedure
#' in the `ernest` package. It can be used for posterior analysis, evidence
#' estimation, and diagnostic plotting.
#'
#' @seealso  [generate()] for how
#' to create a new `ernest_run` object. [plot()] and [calculate()] on how to use
#' `ernest_run` objects to examine uncertainty in the log volume estimates.
#' @examples
#' # Load an example of a nested sampling run
#' data(example_run)
#' example_run
NULL
