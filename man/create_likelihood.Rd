% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/likelihood-class.R
\name{create_likelihood}
\alias{create_likelihood}
\alias{ernest_likelihood}
\title{Prepare a likelihood function for nested sampling}
\usage{
create_likelihood(fn, matrix_fn, on_nonfinite = c("warn", "quiet", "abort"))
}
\arguments{
\item{fn, matrix_fn}{A function to compute log-likelihood values. Choose one
of \code{fn} or \code{matrix_fn}:
\itemize{
\item \code{fn}: Accepts a numeric vector of parameters and returns a scalar
log-likelihood.
\item \code{matrix_fn}: Accepts a numeric matrix of parameters, with each row a vector
of parameters, and returns a numeric vector of log-likelihoods.
}}

\item{on_nonfinite}{A case-sensitive string specifying what to do when \code{fn}
returns a non-finite value other than \code{-Inf} (i.e., \code{NaN}, \code{NA}, \code{Inf}):
\itemize{
\item \code{"warn"}: Issue a warning and return \code{-Inf}.
\item \code{"quiet"}: Silently return \code{-Inf}.
\item \code{"abort"}: Stop execution and signal an error.
}}
}
\value{
A function with class \code{ernest_likelihood}.
}
\description{
Creates a modified version of a log-likelihood function that always returns
either a finite value or \code{-Inf} for each vector of parameters provided.
}
\details{
Provide model likelihoods as a log-density function, which take a vector of
free parameter values and return the corresponding log-likelihood value.

Likelihoods are typically the most computationally expensive function to
evaluate in a nested sampling run. ernest allows you to implement your
likelihood as a function over a single parameter vector (\code{fn}) or over a
matrix of parameters (\code{matrix_fn}). Use \code{fn} or \code{matrix_fn} to select the
method:
\itemize{
\item \code{fn}: Expects a single parameter vector and returns a scalar likelihood.
Internally, \code{create_likelihood} wraps this function with \link{apply}, so it can
be called over matrices of parameters.
\item \code{matrix_fn}: Expects a matrix of parameter vectors (rows as samples,
columns as parameters) and returns a vector of log-likelihoods for each row.
}

In both cases, ernest expects the log-likelihood function to return a
finite double or \code{-Inf} for each parameter vector. The behaviour when
encountering non-finite values other than \code{-Inf} (such as \code{NaN}, \code{Inf}, or
\code{NA}) is controlled by \code{on_nonfinite}.

If your log-likelihood depends on additional data (e.g., an observation
matrix or data frame), provide these using an
(anonymous function)\code{\link[rlang:as_function]{rlang::as_function()}} (see Examples).
}
\examples{
library(mvtnorm)

# Example data and model
data("PlantGrowth")
mod <- lm(weight ~ group, data = PlantGrowth)
frame <- model.frame(mod)
outcome <- model.response(frame)
predictors <- model.matrix(weight ~ group, frame)

# Log-likelihood function for a linear model (vector input)
simple_log_lik <- function(predictors, outcome) {
  function(theta) {
    mu <- predictors \%*\% theta[1:3]
    sigma <- theta[4]
    sum(stats::dnorm(outcome, mean = mu, sd = sigma, log = TRUE))
  }
}

# Create likelihood using a vector-based function
simple_ll <- create_likelihood(fn = simple_log_lik(predictors, outcome))

# Log-likelihood function for a linear model (matrix input)
fast_log_lik <- function(predictors, outcome) {
  n_obs <- length(outcome)
  function(theta) {
    if (!is.matrix(theta)) {
      dim(theta) <- c(1, 4)
    }
    apply(
      theta,
      1,
      \(row) {
        dmvnorm(
          outcome,
          mean = predictors \%*\% row[1:3],
          sigma = diag(row[4]^2, nrow = n_obs),
          log = TRUE
        )
      }
    )
  }
}

# Create likelihood using a matrix-based function
fast_ll <- create_likelihood(matrix_fn = fast_log_lik(predictors, outcome))

# Example: Evaluate at MLE
params <- c(mod$coefficients, summary(mod)$sigma)
simple_ll(params)
fast_ll(params)

# Example: Evaluate a matrix of parameters
param_mat <- matrix(
  rep(params, 2),
  ncol = 4,
  byrow = TRUE
)
param_mat[2, 4] <- param_mat[2, 4] / 2
simple_ll(param_mat)
fast_ll(param_mat)

# Handling non-finite values (default: warn and replace with -Inf)
simple_ll(c(mod$coefficients, NA))

# Control non-finite handling with on_nonfinite
abort_ll <- create_likelihood(
  fn = simple_log_lik(predictors, outcome),
  on_nonfinite = "abort"
)
try(abort_ll(c(mod$coefficients, NA)))

quiet_ll <- create_likelihood(
  fn = simple_log_lik(predictors, outcome),
  on_nonfinite = "quiet"
)
quiet_ll(c(mod$coefficients, NA))
}
