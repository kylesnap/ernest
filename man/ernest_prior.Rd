% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prior-class.R, R/special_priors.R
\name{create_prior}
\alias{create_prior}
\alias{ernest_prior}
\alias{+.ernest_prior}
\alias{create_normal_prior}
\alias{create_uniform_prior}
\title{Specify a prior distribution for nested sampling}
\usage{
create_prior(
  fn,
  names = NULL,
  lower = NULL,
  upper = NULL,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)

\method{+}{ernest_prior}(x, y)

create_normal_prior(
  names = NULL,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)

create_uniform_prior(
  names = NULL,
  lower = 0,
  upper = 1,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)
}
\arguments{
\item{fn}{A function specifying the prior transformation.}

\item{names}{Unique names for each variable in the prior distribution.
Optional for non-custom prior distributions.}

\item{lower, upper}{Numeric vectors. Expected bounds for the
parameter vectors after hypercube transformation.}

\item{repair}{Describes how to repair the vector of \code{names}. One of
\code{"check_unique"}, \code{"unique"}, \code{"universal"}, \code{"unique_quiet"},
or \code{"universal_quiet"}. See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for descriptions of each
repair strategy.}

\item{x, y}{\code{ernest_prior} objects.}

\item{mean}{vector of means.}

\item{sd}{vector of standard deviations.}
}
\value{
A list with class \code{ernest_prior}, containing \code{fn}, \code{lower}, \code{upper},
and \code{names}. The vector-valued parameters are guaranteed to be of common
length.
}
\description{
Use an R function to specify the prior distribution of parameters for a
nested sampling run.
}
\details{
The unit hypercube transformation encodes points in the parameter space
as independent and identically distributed points within a unit hypercube.
Nested sampling implementations, including ernest, use this transformation
to simplify likelihood-restricted prior sampling and avoid unnecessary
rejection steps.

\code{create_prior} allows you to specify your own prior distribution by providing
a transformation function. For factorisable priors, this function can simply
transform each value in the closed interval (0, 1) using the inverse
cumulative distribution function (CDF) for each parameter. For more complex
cases, you can specify hierarchical or conditionally dependent priors
(see Examples).

\code{create_prior} performs regularity checks on your prior function to catch
basic errors that may affect nested sampling. To pass these checks, the
function must take in a vector of points (each between 0 and 1)
and return a vector or matrix of the same shape containing only finite
values.
}
\note{
See \link[vctrs:theory-faq-recycling]{vctrs::vector_recycling_rules} for additional information on
how parameters are recycled to a common length.
}
\examples{
data("PlantGrowth")

# Linear model: weight ~ group
mod <- lm(weight ~ group, data = PlantGrowth)
frame <- model.frame(mod)
predictors <- model.matrix(weight ~ group, frame)

# Prior for regression coefficients (Normal(0, 10))
coef_prior <- create_normal_prior(
  names = colnames(predictors),
  mean = 0,
  sd = 10
)
coef_prior
coef_prior$fn(rep(0.5, length(coef_prior$names)))

# Prior for standard deviation (Truncated Normal(0, 10), lower bound 0)
sd_prior <- create_prior(
  fn = function(x) extraDistr::qtnorm(x, mean = 0, sd = 10, a = 0),
  names = "sigma"
)
sd_prior
sd_prior$fn(0.5)

# Combine priors for full parameter vector (coefficients + sigma)
full_prior <- coef_prior + sd_prior
full_prior
full_prior$fn(rep(0.5, 4))
}
