% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prior-class.R, R/special_priors.R
\name{create_prior}
\alias{create_prior}
\alias{ernest_prior}
\alias{c.ernest_prior}
\alias{create_normal_prior}
\alias{create_uniform_prior}
\title{Specify a prior distribution for nested sampling}
\usage{
create_prior(
  fn,
  names = NULL,
  lower = NULL,
  upper = NULL,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)

\method{c}{ernest_prior}(...)

create_normal_prior(
  names = NULL,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)

create_uniform_prior(
  names = NULL,
  lower = 0,
  upper = 1,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)
}
\arguments{
\item{fn}{A function. Takes a vector of unit cube coordinates and
returns a vector of parameters of the same length.}

\item{names}{Unique names for each variable in the prior distribution.
Optional for non-custom prior distributions.}

\item{lower, upper}{Numeric vectors. Expected bounds for the
parameter vectors after hypercube transformation.}

\item{repair}{Describes how to repair the vector of \code{names}. One of
\code{"check_unique"}, \code{"unique"}, \code{"universal"}, \code{"unique_quiet"},
or \code{"universal_quiet"}.
See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for descriptions of each repair strategy.}

\item{...}{A collection of \code{ernest_prior} objects.}

\item{mean}{vector of means.}

\item{sd}{vector of standard deviations.}
}
\value{
A list with with class \code{ernest_prior}, containing \code{fn}, \code{lower}, \code{upper},
and \code{names}. The vector-valued parameters are guaranteed to be of
length \code{n_dim} if provided, or share a common length if otherwise left
\code{NULL}.
}
\description{
Use an R function to specify the prior distribution of parameters for a
nested sampling run.
}
\details{
The unit hypercube transformation encodes points in the parameter space
as independent and identically distributed points within a unit hypercube.
Nested sampling implementations, including ernest, use this transformation
to simplify likelihood-restricted prior sampling and avoid unnecessary
rejection steps.

\code{create_prior} allows you to specify your own prior distribution by providing
a transformation function. For factorisable priors, this function can simply
transform each value in (0, 1) using the inverse cumulative distribution
function (CDF) for each parameter. For more complex cases, you can specify
hierarchical or conditionally dependent priors (see Examples).

\code{create_prior} performs regularity checks on your prior function to catch
basic errors that may affect nested sampling. To pass these checks, \code{fn} must
be able to take in a vector of points (each between 0 and 1) and return
a vector of the same length which contains only finite values.
}
\note{
See \link[vctrs:theory-faq-recycling]{vctrs::vector_recycling_rules} for additional information on
how parameters are recycled to a common length.
}
\examples{
data(epilepsy, package = "brms")

# Pooled Model of Seizure Count via. Treatment and Baseline Seizure Count:
# glm(count ~ zBase * Trt, family = poisson(), data = epilepsy)
#
# Using a weakly-informative prior
# All coefficients (b0, b1, b2, b1_2) follow N(0, 10)
pooled_prior <- create_normal_prior(
  names = c("b0", "b1", "b2", "b1_2"),
  mean = 0,
  sd = 10
)
pooled_prior
pooled_prior$fn(c(0.5, 0.5, 0.5, 0.5))

# Random-Intercept Model of Seizure-Treatment Relationship:
# brm(
#   count ~ zBase * Trt + (1 | patient),
#   data = epilepsy,
#   family = poisson(),
#   prior = prior(normal(0, 10), class = b) + prior(cauchy(0, 2), class = sd)
# )
#
# Random Intercepts follow N(mu, sd)
# Remaining coefficients (b1, b2, b1_2) follow N(0, 10)
patients <- as.character(unique(epilepsy$patient))
n_groups <- length(patients)
intercept_transform <- function(x) {
  mu <- stats::qnorm(x[1], mean = 0, sd = 10) # Hyperparameter `mu`
  sd <- extraDistr::qtnorm(x[2], mean = 0, sd = 10, a = 0) # Hyperparameter `sd`
  intercept <- stats::qnorm(x[3:(n_groups + 2)], mean = mu, sd = sd)
  c(mu, sd, intercept)
}

intercept_prior <- create_prior(
  intercept_transform,
  names = c("mu", "sd", patients)
)
intercept_prior
intercept_prior$fn(rep(0.5, n_groups + 2))

population_prior <- create_normal_prior(
  names = c("b1", "b2", "b1_2"),
  mean = 0,
  sd = 10
)

# Combine priors using `c()`
full_prior <- c(intercept_prior, population_prior)
print(full_prior)
}
