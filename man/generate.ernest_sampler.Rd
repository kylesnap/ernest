% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate.R
\name{generate.ernest_sampler}
\alias{generate.ernest_sampler}
\alias{ernest_run}
\title{Run nested sampling to estimate Bayesian evidence}
\usage{
\method{generate}{ernest_sampler}(
  x,
  ...,
  max_iterations = NULL,
  max_evaluations = NULL,
  min_logz = 0.05,
  show_progress = NULL
)
}
\arguments{
\item{x}{An object of class \code{ernest_sampler} or \code{ernest_run}.}

\item{...}{
  Arguments passed on to \code{\link[=compile.ernest_run]{compile.ernest_run}}
  \describe{
    \item{\code{clear}}{Logical. If \code{TRUE}, clears results from previous runs before
compiling. If \code{FALSE}, retains previous results and validates live points.}
  }}

\item{max_iterations}{Optional positive integer. The maximum number of
iterations to perform. If \code{NULL}, this criterion is ignored.}

\item{max_evaluations}{Optional positive integer. The maximum number of
likelihood function evaluations to perform. If \code{NULL}, this criterion is
ignored.}

\item{min_logz}{Non-negative double. The minimum log-ratio between the
current estimated evidence and the remaining evidence. If zero, this
criterion is ignored.}

\item{show_progress}{Logical. If \code{TRUE}, displays a progress spinner and
iteration counter during sampling. If \code{NULL}, then the parameter is inferred
based on the value of the \code{rlib_message_verbosity} option.}
}
\value{
An object of class \code{ernest_run}, inheriting from \code{ernest_sampler},
with additional components:
\itemize{
\item \code{niter}: Integer. Number of iterations.
\item \code{n_evaluations}: Integer. Total number of likelihood function evaluations.
\item \code{log_lik}: \code{double(niter + nlive)}. Log-likelihoods for each sample.
\item \code{log_volume}: \code{double(niter + nlive)}. Estimated log-prior volumes at
each iteration.
\item \code{log_weight}: \code{double(niter + nlive)}. Unnormalised log-weights for
each sample.
\item \code{log_evidence}: \code{double(niter + nlive)}. Cumulative log-evidence
estimates at each iteration.
\item \code{log_evidence_var}: \code{double(niter + nlive)}. Variance of the
log-evidence estimate at each iteration.
\item \code{information}: \code{double(niter + nlive)}. KL divergence between the prior
and posterior, estimated at each iteration.
\item \code{samples}: \code{matrix(nrow = niter + nlive, ncol = n_dim)}. Parameter
values for each sample.
\item \code{samples_unit}: \code{matrix(nrow = niter + nlive, ncol = n_dim)}. Parameter
values for each sample in unit hypercube representation.
\item \code{id}: \code{integer(niter + nlive)}. Unique integer identifiers for each
sample from the live set (ranging from 1 to \code{nlive}).
\item \code{points}: \code{integer(niter + nlive)}. Number of live points present at
each iteration.
\item \code{evaluations}: \code{integer(niter + nlive)}. Number of likelihood function evaluations used to generate a
new live point at each iteration.
\item \code{birth_lik}: \code{integer(niter + nlive)}. \code{id} of the live point that was used
to create the given point. \code{0} if the point was created by \code{compile} at the
beginning of a run.
}
}
\description{
Executes the nested sampling algorithm, iteratively replacing the worst live
point with a new sample from a likelihood-restricted prior until a stopping
criterion is met.
}
\details{
At least one of \code{max_iterations}, \code{max_evaluations}, or \code{min_logz}
must specify a valid stopping criterion. Setting \code{min_logz} to zero while
leaving \code{max_iterations} and \code{max_evaluations} at their defaults will
result in an error.

If \code{x} is an \code{ernest_run} object, the stopping criteria are checked against
the current state of the run. An error is thrown if the stopping criteria
have already been satisfied by \code{x}.

The \code{min_logz} parameter controls the relative tolerance for the remaining
evidence in the unexplored parameter space. Sampling stops when the estimated
remaining evidence is sufficiently small compared to the accumulated
evidence.
}
\examples{
prior <- create_uniform_prior(lower = c(-1, -1), upper = 1)
ll_fn <- function(x) -sum(x^2)
sampler <- ernest_sampler(ll_fn, prior, n_point = 100)
sampler

# Stop sampling after a set number of iterations or likelihood calls.
generate(sampler, max_iterations = 100)

# The final number of calls may exceed `max_evaluations`, as `generate`
# only checks the number of calls when removing a live point.
generate(sampler, max_evaluations = 2600)
# Use the default stopping criteria
\dontrun{ generate(sampler) }
}
\references{
Skilling, J. (2006). Nested Sampling for General Bayesian
Computation. Bayesian Analysis, 1(4), 833â€“859. \doi{10.1214/06-BA127}
}
