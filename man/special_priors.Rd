% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/special_priors.R
\name{create_normal_prior}
\alias{create_normal_prior}
\alias{create_uniform_prior}
\title{Uniform distribution}
\usage{
create_normal_prior(
  names = NULL,
  mean = 0,
  sd = 1,
  lower = -Inf,
  upper = Inf,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)

create_uniform_prior(
  names = NULL,
  lower = 0,
  upper = 1,
  repair = c("unique", "universal", "check_unique", "unique_quiet", "universal_quiet")
)
}
\arguments{
\item{names}{\verb{[character()]}\cr Optional names for each parameter.
If \code{NULL}, default names and indices are generated.}

\item{mean, sd}{\verb{[double()]}\cr Mean and standard deviation for each marginal
normal distribution. \code{sd} must be strictly positive.}

\item{lower, upper}{\verb{[double()]}\cr Lower and upper bounds for each parameter.
If used with \code{create_normal_prior()}, these define the truncation limits.}

\item{repair}{\verb{[character(1)]}\cr Name repair strategy for \code{names}. One of
\code{"check_unique"}, \code{"unique"}, \code{"universal"}, \code{"unique_quiet"}, or
\code{"universal_quiet"}. See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for details.}
}
\value{
An \link{ernest_prior}, additionally inheriting from the specialized
class \code{uniform_prior} or \code{normal_prior}.
}
\description{
Uniform distribution
}
\details{
The provided transformations are vectorized: they accept a matrix of points
in the unit hypercube and return a matrix of transformed values.
}
\examples{
# Specify a prior with independent marginals
normal <- create_normal_prior(
  names = c("beta0", "beta1", "beta2"),
  mean = 0,
  sd = 5
)
uniform <- create_uniform_prior(names = "sd", lower = 0, upper = 5)
composite <- normal + uniform
composite

# Propose a conditional (hierarchical) prior in vectorized form
fn <- function(x) {
  n <- nrow(x)
  out <- matrix(NA_real_, nrow = n, ncol = 3)
  # x[1] follows N(5, 1)
  out[, 1] <- stats::qnorm(x[, 1], mean = 5, sd = 1)
  # log10(x[2]) follows Uniform(-1, 1)
  out[, 2] <- 10^stats::qunif(x[, 2], min = -1, max = 1)
  # x[3] follows N(x[1], x[2])
  out[, 3] <- stats::qnorm(x[, 3], mean = out[, 1], sd = out[, 2])
  out
}

conditional_prior <- create_prior(
  vectorized_fn = fn,
  names = c("mean", "sd", "x"),
  lower = c(-Inf, 0, -Inf)
)

# Plot the marginals
sample <- conditional_prior$fn(matrix(runif(1000 * 3), nrow = 1000))
hist(sample[, 1], main = "mean")
hist(sample[, 2], main = "sd")
hist(sample[, 3], main = "x")
}
\seealso{
\code{\link[=create_prior]{create_prior()}} for more on priors within nested sampling.

Other priors: 
\code{\link{create_prior}()}
}
\concept{priors}
