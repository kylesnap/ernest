#' Algorithmic Tests

log_lik_fn <- gaussian_blobs$log_lik
unif_prior <- gaussian_blobs$prior

result <- NULL
smry_base <- NULL

#' @srrstats {G5.7} These tests all demonstrate that change ernest's
#' computational parameters changes the behaviour of the NS algorithm
#' as expected.
describe("gaussian_blobs", {
  it("works with rwalk", {
    sampler <- ernest_sampler(log_lik_fn, unif_prior, n_points = 100)
    result <<- generate(sampler, seed = 42)
    smry_base <<- summary(result)

    expect_lt(
      abs(smry_base$log_evidence - gaussian_blobs$analytic_z),
      3.0 * smry_base$log_evidence_err
    )
    weights <- as_draws(result) |>
      weights()
    expect_equal(sum(weights), 1)
  })

  it("works with unif_ellipsoid", {
    sampler <- ernest_sampler(
      log_lik_fn,
      unif_prior,
      sampler = unif_ellipsoid(1.1),
      n_points = 200
    )
    unif_result <- generate(sampler, seed = 42)
    unif_smry <- summary(unif_result)

    expect_lt(
      abs(unif_smry$log_evidence - gaussian_blobs$analytic_z),
      3.0 * unif_smry$log_evidence_err
    )
    weights <- as_draws(unif_result) |>
      weights()
    expect_equal(sum(weights), 1)
  })

  it("works with unif_cube", {
    skip_extended_test()
    sampler <- ernest_sampler(
      log_lik_fn,
      unif_prior,
      sampler = unif_cube(),
      n_points = 100
    )
    unif_result <- generate(sampler, min_logz = 0.5, seed = 42)
    unif_smry <- summary(unif_result)

    expect_lt(
      abs(unif_smry$log_evidence - gaussian_blobs$analytic_z),
      3.0 * unif_smry$log_evidence_err
    )
    weights <- as_draws(unif_result) |>
      weights()
    expect_equal(sum(weights), 1)
  })
})

#' @srrstats {BS4.6} Test checks that the NS converegence criteria
#' (min_logz) produce identical results to when the number of iterations
#' is set to a fixed value.
test_that("iterations and min_logz produce near-identical results", {
  sampler <- ernest_sampler(log_lik_fn, unif_prior, n_points = 100)
  result_iter <- generate(
    sampler,
    max_iterations = result$n_iter,
    min_logz = 0,
    seed = 42L
  )
  smry_iter <- summary(result_iter)

  expect_lt(
    abs(smry_iter$log_evidence - gaussian_blobs$analytic_z),
    3.0 * smry_iter$log_evidence_err
  )
  expect_lt(
    abs(smry_iter$log_evidence - smry_base$log_evidence),
    smry_iter$log_evidence_err
  )
})

test_that("`n_points` changes the iterations needed for convergence", {
  skip_extended_test()
  sampler_500 <- ernest_sampler(
    log_lik_fn,
    unif_prior,
    n_points = 500
  )
  run_500 <- generate(sampler_500, seed = 42L)
  smry_500 <- summary(run_500)

  expect_lt(
    smry_500$log_evidence - gaussian_blobs$analytic_z,
    3 * smry_500$log_evidence_err
  )
  expect_gt(smry_500$n_iter, smry_base$n_iter)
})

#' @srrstats {BS4.7} Test checks that the NS converegence criteria (min_logz)
#' changes the number of iterations needed for the sampler to converge.
test_that("increasing min_logz reduces the iterations needed to converge", {
  skip_extended_test()
  sampler <- ernest_sampler(log_lik_fn, unif_prior, n_points = 100)
  run_01 <- generate(sampler, min_logz = 0.1, seed = 42L)
  smry_01 <- summary(run_01)

  expect_lt(
    smry_01$log_evidence - gaussian_blobs$analytic_z,
    3 * smry_01$log_evidence_err
  )
  expect_lt(smry_01$n_iter, smry_base$n_iter)
})

#' @srrstats {BS7.3} The scale of the prior should impact the iterations
#' needed for NS to converge an evidence estimate.
test_that("increasing prior vol. increases iterations needed to converge", {
  skip_extended_test()
  wide_prior <- create_uniform_prior(n_dim = 2, lower = -10, upper = 10)
  sampler_wide <- ernest_sampler(log_lik_fn, wide_prior, n_points = 500)
  run_wide <- generate(sampler_wide, seed = 42L)
  smry_wide <- summary(run_wide)

  expect_lt(
    smry_wide$log_evidence - gaussian_blobs$analytic_z,
    3.0 * smry_wide$log_evidence_err
  )
  expect_lt(smry_base$n_iter, smry_wide$n_iter)
  expect_lt(
    tail(smry_base$run$information, 1L),
    tail(smry_wide$run$information, 1L)
  )
})
