---
title: "Nested Sampling with Ernest"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Nested Sampling with Ernest}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ernest)
```

The Easy R Nested Sampling Toolkit (ernest) provides a collection of tools for performing nested sampling within `R`. To begin sampling, ernest requires the user to specify two objects:

1. A log-likelihood function,
2. A prior distribution, provided in the form of an `ernest_prior` object.

The log-likelihood function must take in a single argument consisting of a vector of parameters, and must return either a finite scalar numeric value or the value `-Inf`. As an example, we can define the log-likelihood of a 3D Gaussian distribution.

```{r}
n_dim <- 3
sigma <- diag(0.95, nrow = 3)
det_sigma <- determinant(sigma, logarithm = TRUE)$modulus
attributes(det_sigma) <- NULL
prec <- solve(sigma)
log_norm <- -0.5 * (log(2 * pi) * n_dim + det_sigma)

# Log-likelihood of a MVN(0, Sigma)
log_lik <- function(theta) {
  drop(-0.5 * crossprod(theta, crossprod(prec, theta)) + log_norm)
}
log_lik(c(0, 0, 0))
```
The prior is provided through an `ernest_prior` object, which contains information about the parameter space of interest. Ernest conducts its sampling within the unit cube, and uses the `ernest_prior` to transform these unit cube samples into the space of the original prior. The user can choose to build their own prior by offering a transformation function explicitly: For every $d$-length vector in the [0,1)-unit cube, this function should output a $d$-length vector of parameters. In the case of independently-distributed parameters, this is identical to applying the inverse cumulative distribution function (CDF) of the prior distribution to each element of the input vector.

This function, along with the number of dimensions within the prior space, is then given to `create_prior()`. This prior specifies a 3D prior space with $Uniform[-10, 10]$ marginals.

```{r}
transformation <- function(x) {
  x * 20 - 10
}

user_prior <- create_prior(
  fn = transformation,
  n_dim = n_dim
)
```

For several priors, ernest provides convenience functions with fast implementations of the required transformation. One such function exists for the uniform distribution:

```{r}
unif_prior <- create_uniform_prior(n_dim, lower = -10, upper = 10)
```
Both objects are forwarded to `nested_sampling()` to prepare a nested sampling run. This function also sets a number of additional parameters to control the sampling process. The most important of these is `n_live`, which specifies the number of live points to use during the sampling process.

```{r}
sampler <- nested_sampling(log_lik, unif_prior, n_points = 1000)
sampler
```

The result is an `ernest_sampler` object, which is an `R6` class. This allows ernest to start or continue nested sampling runs using previous results. The nested sampling loop is started by calling the `generate` method for `ernest_sampler`, which will perform sampling until some stopping criteria is met. By default, this criterion is the estimated untraversed prior volume falling below 0.05.

```{r}
run <- generate(sampler)
sampler$run
```

Results are stored in `ernest_run` objects, which themselves have several methods. This includes `summary`, which provides the estimate evidence estimates as a `tibble`, and `plot`, which visualizes how the evidence estimates and related quantities changed throughout a run.

```{r}
summary(run)$run |> head()
plot(run)
```
